{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Schemathesis","text":"<p>Schemathesis automatically generates and runs API tests from your OpenAPI or GraphQL schema to find bugs and spec violations.</p> <p> Automatically finding specification violations and server errors </p>"},{"location":"#why-schemathesis","title":"Why Schemathesis?","text":"<ul> <li>\ud83d\udd2c Research-backed testing: Validated in academic research and recognized in an ACM survey as a state-of-the-art API testing tool</li> <li>\ud83d\udd0d Schema-Based Generation - Creates test cases directly from your API documentation</li> <li>\ud83d\udee1\ufe0f Zero Configuration - Works immediately with any valid OpenAPI or GraphQL schema</li> <li>\ud83d\udd04 Advanced Testing Techniques - Employs stateful testing, boundary analysis, and fuzzing</li> <li>\ud83e\uddea Continuous Testing - Integrates with CI/CD pipelines for automated verification</li> <li>\u26a1 Extensive Coverage - Tests more scenarios than manual scenarios can reasonably cover</li> </ul>      \"The tool is amazing as it can test negative scenarios instead of me and much faster!\"    \u2014 Lud\u011bk Nov\u00fd, JetBrains"},{"location":"#try-it","title":"Try It","text":"<pre><code># Quickest way to start:\n$ uvx schemathesis run http://example.schemathesis.io/openapi.json\n</code></pre> <p>For installing Schemathesis, we recommend using uv, a fast Python package installer and environment manager.</p> <p>See Getting Started for installation options and your first test run.</p>"},{"location":"#documentation","title":"Documentation","text":"Getting Started <p>Install Schemathesis and run your first API test in minutes</p> Core Concepts <p>Understand how Schemathesis generates and executes tests</p> CLI Guide <p>Learn how to use Schemathesis from the command line</p> Python Integration <p>Embed API testing directly in your Python test suites</p>"},{"location":"#schema-support","title":"Schema Support","text":"<ul> <li>OpenAPI: 2.0 (Swagger), 3.0, and 3.1</li> <li>GraphQL: 2018 specification</li> </ul>"},{"location":"#learn-more","title":"Learn More","text":"<ul> <li> <p>Using Schemathesis \u2014 Practical guides for running tests with different interfaces</p> <ul> <li>Command-Line Interface</li> <li>Python Integration</li> <li>Continuous Integration</li> <li>Configuration</li> </ul> </li> <li> <p>Extending Schemathesis \u2014 Customize and enhance testing capabilities</p> <ul> <li>Custom Checks</li> <li>Data Generation</li> <li>Authentication</li> <li>Hooks</li> </ul> </li> <li> <p>Reference \u2014 Comprehensive documentation of all options and settings</p> <ul> <li>Configuration Options</li> <li>CLI Options</li> <li>Checks</li> <li>Reporting</li> </ul> </li> <li> <p>Resources \u2014 Community articles, videos, and tutorials</p> </li> <li> <p>Troubleshooting \u2014 Solve common issues</p> </li> </ul>"},{"location":"core-concepts/","title":"Core Concepts","text":"<p>Here\u2019s an overview of how Schemathesis works:</p> <ol> <li>Test Generation: Using the API schema to create a test generator that you can fine-tune to your requirements.</li> <li>Execution and Adaptation: Sending tests to the API and adapting through statistical models and heuristics to optimize test cases based on responses.</li> <li>Analysis and Minimization: Checking responses for issues and simplifying failing test cases for easier debugging.</li> <li>Stateful Testing: Running multi-step tests to assess API operations in both isolated and integrated scenarios.</li> <li>Reporting: Generating detailed reports with insights and cURL commands for easy issue reproduction.</li> </ol>"},{"location":"core-concepts/#test-phases","title":"Test Phases","text":""},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#what-kind-of-data-does-schemathesis-generate","title":"What kind of data does Schemathesis generate?","text":"<p>Schemathesis generates three types of test data:</p> <ul> <li>Explicit examples directly from your API schema (when available)</li> <li>Valid data that conforms to your API schema's constraints</li> <li>Invalid data that deliberately violates schema constraints (when using negative testing modes, currently limited to OpenAPI tests)</li> </ul> <p>For OpenAPI schemas, the data generation covers all JSON Schema data types and their combinations, with varying complexity and edge cases. For GraphQL, Schemathesis generates valid queries based on the schema structure.</p> <p>While Schemathesis attempts to generate realistic data based on schema constraints, it may occasionally generate data that is rejected by your application due to validation rules not expressed in the schema.</p>"},{"location":"faq/#what-types-of-api-issues-can-schemathesis-find","title":"What types of API issues can Schemathesis find?","text":"<p>Schemathesis identifies problems in three main categories:</p> <p>API Contract Violations</p> <ul> <li>Responses not matching documented schemas</li> <li>Undocumented status codes</li> <li>Missing or incorrect content types</li> </ul> <p>Implementation Flaws</p> <ul> <li>Server errors (5xx responses)</li> <li>Data validation issues (accepting invalid data or rejecting valid data)</li> <li>Authentication bypasses</li> </ul> <p>Stateful Behavior Issues</p> <ul> <li>Resources accessible after deletion</li> <li>Resources unavailable after creation</li> </ul>"},{"location":"faq/#how-should-i-run-schemathesis","title":"How should I run Schemathesis?","text":"<p>Schemathesis can be run in two primary ways:</p> <ul> <li>As a CLI tool: Ideal for testing APIs built in any programming language. The CLI offers the most complete feature set, including all test phases, comprehensive reporting, and stateful testing. This is the recommended approach for most users.</li> <li>As a Python library: Useful for Python applications where you want to integrate with existing pytest test suites. While the Python API has some limitations compared to the CLI due to pytest constraints, it offers more opportunities for customization and extension.</li> </ul> <p>Choose the CLI approach for the most comprehensive testing capabilities and language-agnostic testing. Use the Python library when you need direct programmatic control or tight integration with your Python testing infrastructure.</p>"},{"location":"faq/#what-if-my-application-doesnt-have-an-api-schema","title":"What if my application doesn't have an API schema?","text":"<p>If your API doesn't have a schema, you have several options:</p> <ol> <li> <p>Generate a schema: Use tools like flasgger (Python), GrapeSwagger (Ruby), or Swashbuckle (ASP.NET) to automatically generate an initial schema from your code.</p> </li> <li> <p>Write a minimal schema: Create a basic schema manually covering just the endpoints you want to test first, then expand it over time.</p> </li> <li> <p>Use schema inference tools: Some third-party tools can observe API traffic and generate a schema based on observed requests and responses.</p> </li> </ol> <p>Starting with an imperfect schema is fine - Schemathesis can help you refine it by identifying inconsistencies between your schema and implementation.</p>"},{"location":"faq/#how-long-does-it-usually-take-for-schemathesis-to-test-an-api","title":"How long does it usually take for Schemathesis to test an API?","text":"<p>Testing duration depends on several factors:</p> <ul> <li>API complexity: More endpoints and parameters mean more tests</li> <li>Test configuration: Settings like <code>--max-examples</code> directly affect the number of tests generated</li> <li>Response time: Slower APIs take longer to test</li> <li>Schema complexity: Complex schemas may require more tests to achieve good coverage</li> </ul> <p>In practice, testing typically takes from a few seconds to a few minutes for most APIs. Very large or complex APIs might take longer, especially with high <code>--max-examples</code> settings or when using stateful testing.</p> <p>You can control testing duration by adjusting the <code>--max-examples</code> parameter and by enabling parallel testing with the <code>--workers</code> option.</p>"},{"location":"faq/#how-is-schemathesis-different-from-other-api-testing-tools","title":"How is Schemathesis different from other API testing tools?","text":"<p>Schemathesis differs from other API testing tools in several key ways:</p> <ul> <li> <p>Property-based testing: Tests API properties (like \"all responses should match their schema\") rather than specific input-output pairs, automatically exploring the input space to find violations.</p> </li> <li> <p>Stateful testing: Schemathesis can test sequences of API calls to find issues that only appear in specific request orders.</p> </li> <li> <p>Failure minimization: When issues are found, Schemathesis automatically simplifies the failing test case to the minimal example that reproduces the problem.</p> </li> <li> <p>Schema-first workflow: While tools like Postman or Insomnia focus on manual request creation, Schemathesis derives all test cases directly from your API specification.</p> </li> </ul> <p>Compared to tools like Dredd, Schemathesis focuses more on finding unexpected edge cases through property-based testing rather than verifying documented examples.</p>"},{"location":"faq/#what-are-the-known-limitations-of-schemathesis","title":"What are the known limitations of Schemathesis?","text":"<p>Schemathesis has the following known limitations:</p>"},{"location":"faq/#schema-processing-limitations","title":"Schema Processing Limitations","text":"<ul> <li>Recursive References:   Schemathesis handles most recursive schemas by cutting recursion at a defined depth. However, in a very small fraction of cases (approximately 25 out of over 100,000 schemas tested), complex recursive patterns involving multiple reference hops may cause errors. For more details, see GitHub issue #947.</li> </ul>"},{"location":"faq/#graphql-limitations","title":"GraphQL Limitations","text":"<ul> <li>Negative Testing:   Schemathesis does not support generating invalid inputs for GraphQL endpoints. The <code>--mode negative</code> and <code>--mode all</code> options are applicable only to OpenAPI schemas.</li> </ul> <p>If you encounter issues not listed here, please report them on our GitHub issues page.</p>"},{"location":"getting-started/","title":"Getting Started with Schemathesis","text":"<p>Schemathesis automatically generates and runs API tests from your OpenAPI or GraphQL schema to find bugs and spec violations.</p>"},{"location":"getting-started/#what-is-schemathesis","title":"What is Schemathesis?","text":"<p>Schemathesis is a property-based testing tool that:</p> <ul> <li>Uses your API schema to generate test cases automatically</li> <li>Validates responses against schema definitions</li> <li>Finds edge cases and bugs without manual test writing</li> <li>Works with OpenAPI (Swagger) and GraphQL schemas</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#using-uv-recommended","title":"Using uv (recommended)","text":"<p>uv is a fast Python package installer and environment manager:</p> <pre><code>$ uv pip install schemathesis\n</code></pre>"},{"location":"getting-started/#run-without-installing","title":"Run without installing","text":"<p>uvx (part of the uv ecosystem) lets you run Schemathesis directly without installation:</p> <pre><code>$ uvx schemathesis run https://example.schemathesis.io/openapi.json\n</code></pre>"},{"location":"getting-started/#using-docker","title":"Using Docker","text":"<pre><code>$ docker pull schemathesis/schemathesis:stable\n$ docker run schemathesis/schemathesis:stable --version\n</code></pre> <p>Verify your installation:</p> <pre><code>$ schemathesis --version\n# or using the shorter command alias\n$ st --version\nSchemathesis 4.0.0\n</code></pre>"},{"location":"getting-started/#testing-a-sample-api","title":"Testing a Sample API","text":"<p>Let's run a basic test against an example API:</p> <pre><code>$ st run https://example.schemathesis.io/openapi.json\n</code></pre> <p>This single command:</p> <ul> <li>Loads the API schema</li> <li>Generates test cases based on schema definitions</li> <li>Sends requests to test endpoints</li> <li>Validates responses with various checks</li> </ul> <p>You should see output similar to this:</p> <pre><code>Schemathesis 4.0.0\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n \u2705  Loaded specification from https://schemathesis.io/openapi.json (in 0.32s)\n\n     Base URL:         http://127.0.0.1/api\n     Specification:    Open API 3.0.2\n     Operations:       1 selected / 1 total\n\n \u2705  API capabilities:\n\n     Supports NULL byte in headers:    \u2718\n\n \u23ed   Examples (in 0.00s)\n\n     \u23ed  1 skipped\n\n \u274c  Coverage (in 0.00s)\n\n     \u274c 1 failed\n\n \u274c  Fuzzing (in 0.00s)\n\n     \u274c 1 failed\n\n=================================== FAILURES ===================================\n_________________________________ GET /success _________________________________\n1. Test Case ID: &lt;PLACEHOLDER&gt;\n\n- Response violates schema\n\n    {} is not of type 'integer'\n\n    Schema:\n\n        {\n            \"type\": \"integer\"\n        }\n\n    Value:\n\n        {}\n\n- Missing Content-Type header\n\n    The following media types are documented in the schema:\n    - `application/json`\n\n[200] OK:\n\n    `{}`\n\nReproduce with:\n\n    curl -X GET http://127.0.0.1/api/success\n\n=================================== SUMMARY ====================================\n\nAPI Operations:\n  Selected: 1/1\n  Tested: 1\n\nTest Phases:\n  \u2705 API probing\n  \u23ed  Examples\n  \u274c Coverage\n  \u274c Fuzzing\n  \u23ed  Stateful (not applicable)\n\nFailures:\n  \u274c Response violates schema: 1\n  \u274c Missing Content-Type header: 1\n\nTest cases:\n  N generated, N found N unique failures\n\nSeed: 42\n\n============================= 2 failures in 1.00s ==============================\n</code></pre>"},{"location":"getting-started/#understanding-test-results","title":"Understanding Test Results","text":"<p>In this test:</p> <ol> <li>Schemathesis found that the API endpoint's response didn't match what was defined in the schema</li> <li>The endpoint was supposed to return an integer, but returned an empty object (<code>{}</code>) instead</li> <li>The response was also missing a required Content-Type header</li> </ol> <p>For each issue found, Schemathesis provides:</p> <ul> <li>An explanation of what went wrong</li> <li>The expected vs. actual values</li> <li>A curl command to help you reproduce the issue</li> </ul>"},{"location":"getting-started/#common-issues-and-troubleshooting","title":"Common Issues and Troubleshooting","text":"<p>Schemathesis identifies these common categories of API problems:</p>"},{"location":"getting-started/#api-contract-violations","title":"API Contract Violations","text":"<ul> <li>Schema violations: Response bodies that don't match the defined schema</li> <li>Status code issues: Unexpected or undocumented HTTP status codes</li> <li>Header problems: Missing or incorrect response headers</li> </ul>"},{"location":"getting-started/#implementation-flaws","title":"Implementation Flaws","text":"<ul> <li>Server errors: 5xx responses indicating server-side problems</li> <li>Data validation issues: APIs accepting invalid data or rejecting valid data</li> <li>Security concerns: Potential authentication bypasses</li> </ul>"},{"location":"getting-started/#stateful-behavior-issues","title":"Stateful Behavior Issues","text":"<ul> <li>Resource state problems: Resources inaccessible after creation or accessible after deletion</li> </ul> <p>When you encounter these issues:</p> <ol> <li>Use the provided curl command to reproduce and verify the problem</li> <li>Check your API implementation against the schema definition</li> <li>Determine if the issue is in the schema (incorrect definition) or the API (incorrect implementation)</li> <li>For schema issues, update your schema definition</li> <li>For API issues, modify your implementation to comply with the schema</li> </ol>"},{"location":"getting-started/#testing-your-own-api","title":"Testing Your Own API","text":"<p>To test your own API:</p> <ol> <li>Make sure your API is running</li> <li>Run Schemathesis against your schema:</li> </ol> <pre><code># If your API serves its own schema\n$ st run https://your-api.com/openapi.json\n\n# If you have a local schema file\n$ st run ./openapi.yaml --url https://your-api.com\n</code></pre> <p>That's it! Schemathesis will automatically generate test cases based on your schema and identify any server errors or compliance issues.</p>"},{"location":"getting-started/#where-to-go-next","title":"Where to Go Next","text":"<ul> <li>Core Concepts - Understand how Schemathesis works</li> <li>Command-Line Interface - Learn all available CLI options</li> <li>Authentication - Configure tests for protected APIs</li> <li>Continuous Integration - Automate API testing in your CI pipeline</li> </ul>"},{"location":"resources/","title":"External Resources","text":"<p>This page collects articles, papers, videos, and tutorials about Schemathesis written by the community. These resources provide additional perspectives, use cases, and implementation examples.</p>"},{"location":"resources/#papers","title":"Papers","text":"<ul> <li> <p>Testing RESTFul APIs: A Survey by Golmohammadi, et al.</p> <ul> <li> <p>Description: Academic review of state-of-the-art API testing tools including Schemathesis.</p> </li> <li> <p>Date: 24 Nov 2023</p> </li> </ul> </li> <li> <p>Deriving Semantics-Aware Fuzzers from Web API Schemas by @Zac-HD and @Stranger6667</p> <ul> <li> <p>Description: Research paper exploring the automation of API testing through semantics-aware fuzzing. Presented at ICSE 2022.</p> </li> <li> <p>Date: 20 Dec 2021</p> </li> </ul> </li> </ul>"},{"location":"resources/#tutorials","title":"Tutorials","text":"<ul> <li> <p>Automated REST API fuzzing using Schemathesis by @RafDevX and @sofiaedv at KTH Royal Institute of Technology</p> <ul> <li> <p>Description: Hands-on tutorial on fuzzing REST APIs with Schemathesis from the course DD2482 Automated Software Testing and DevOps</p> </li> <li> <p>Date: 15 Oct 2023</p> </li> </ul> </li> </ul>"},{"location":"resources/#articles","title":"Articles","text":"<ul> <li> <p>Create a Cracker of an Open API Contract with VS Code, Spectral, Prism and Schemathesis by @dataGriff</p> <ul> <li> <p>Description: Detailed walkthrough of contract-first API design and testing workflow.</p> </li> <li> <p>Date: 22 Dec 2023</p> </li> </ul> </li> <li> <p>Boost Your FastAPI Reliability with Schemathesis Automated Testing by @Jeremy</p> <ul> <li> <p>Description: Implementation guide for Schemathesis testing in FastAPI projects.</p> </li> <li> <p>Date: 17 Jul 2023</p> </li> </ul> </li> <li> <p>Implementing Schemathesis at PayLead by J\u00e9r\u00e9my Pelletier at PayLead</p> <ul> <li> <p>Description: Case study including custom hooks, stateful testing, and CI/CD integration.</p> </li> <li> <p>Date: 29 May 2023</p> </li> </ul> </li> <li> <p>Auto-Generating &amp; Validating OpenAPI Docs in Rust: A Streamlined Approach with Utoipa and Schemathesis by identeco</p> <ul> <li> <p>Description: Integration of OpenAPI doc generation with Utoipa and validation with Schemathesis in Rust applications.</p> </li> <li> <p>Date: 01 Jun 2023</p> </li> </ul> </li> <li> <p>Testing APIFlask with schemathesis by @pamelafox</p> <ul> <li> <p>Description: Technical guide for testing APIFlask applications using Schemathesis.</p> </li> <li> <p>Date: 27 Feb 2023</p> </li> </ul> </li> <li> <p>Using Hypothesis and Schemathesis to Test FastAPI by @amalshaji</p> <ul> <li> <p>Description: Technical overview of property-based testing in FastAPI with Hypothesis and Schemathesis.</p> </li> <li> <p>Date: 06 Sep 2022</p> </li> </ul> </li> <li> <p>How to use Schemathesis to test Flask API in GitHub Actions by @lina-is-here</p> <ul> <li> <p>Description: Implementation guide for Schemathesis with Flask API in GitHub Actions.</p> </li> <li> <p>Date: 04 Aug 2022</p> </li> </ul> </li> <li> <p>Using API schemas for property-based testing (in Russian) by @Stranger6667</p> <ul> <li> <p>Description: Technical article covering Schemathesis for property-based API testing.</p> </li> <li> <p>Date: 07 Sep 2021</p> </li> </ul> </li> <li> <p>Schemathesis: property-based testing for API schemas by @Stranger6667</p> <ul> <li> <p>Description: Introduction to the concepts behind Schemathesis and property-based testing for APIs.</p> </li> <li> <p>Date: 26 Nov 2019</p> </li> </ul> </li> </ul>"},{"location":"resources/#videos","title":"Videos","text":"<ul> <li> <p>API Fuzzing: What it is and why you should use it by Jos\u00e9 Haro Peralta</p> <ul> <li> <p>Description: Technical overview and demonstration of Schemathesis capabilities.</p> </li> <li> <p>Date: 14 Feb 2023</p> </li> </ul> </li> <li> <p>Automated Testing with Schemathesis with video tutorial by Red Hat</p> <ul> <li> <p>Description: Hands-on tutorial for implementing API testing with Schemathesis.</p> </li> <li> <p>Date: 09 Feb 2023</p> </li> </ul> </li> <li> <p>Effective API schemas testing from DevConf.cz by @Stranger6667</p> <ul> <li> <p>Description: Technical presentation on Schemathesis for property-based API schema testing.</p> </li> <li> <p>Date: 24 Mar 2021</p> </li> </ul> </li> <li> <p>API-schema-based testing with schemathesis from EuroPython 2020 by @hultner</p> <ul> <li> <p>Description: Technical introduction to property-based API testing with Schemathesis.</p> </li> <li> <p>Date: 23 Jul 2020 </p> </li> </ul> </li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"advanced/targeted/","title":"Targeted Property-Based Testing","text":"<p>Schemathesis supports targeted property-based testing to guide test data generation toward specific goals. This technique helps find problematic inputs faster by directing the test generator toward areas more likely to reveal issues.</p>"},{"location":"advanced/targeted/#maximizing-metrics","title":"Maximizing Metrics","text":"<p>The <code>--generation-maximize</code> option instructs Schemathesis to favor inputs that maximize a specific metric:</p> <pre><code>$ st run openapi.yaml --generation-maximize response_time\n</code></pre> <p>Currently supported metrics:</p> <ul> <li><code>response_time</code>: Favors inputs that result in longer API response times</li> </ul> <p>This approach is particularly useful for detecting:</p> <ul> <li>Performance bottlenecks</li> <li>Inputs that cause excessive processing</li> <li>Potential denial-of-service vulnerabilities</li> </ul> <p>Custom Metrics</p> <p>See Extending Metrics for details on implementing custom metrics for targeted testing.</p>"},{"location":"advanced/targeted/#example-scenario","title":"Example Scenario","text":"<p>Consider an API endpoint with a hidden performance issue where inputs containing many zeros cause progressively slower responses. At a certain threshold, the endpoint fails completely:</p> <pre><code>async def performance(request):\n    decoded = await request.json()\n    number = str(decoded).count(\"0\")\n    if number &gt; 0:\n        # Progressively slower as zeros increase\n        await asyncio.sleep(0.01 * number)\n    if number &gt; 10:\n        # Fails with too many zeros\n        raise ServerError()\n    return {\"result\": \"success\"}\n</code></pre> <p>When testing this endpoint:</p> <ul> <li>Standard testing might need many examples to stumble upon problematic inputs</li> <li>Targeted testing will progressively favor inputs with more zeros, finding the issue faster</li> </ul>"},{"location":"advanced/targeted/#performance-advantage","title":"Performance Advantage","text":"<p>In practice, targeted testing can significantly reduce the time needed to discover issues:</p> <pre><code># Standard testing might require many examples\n$ st run openapi.yaml --max-examples=10000\n\n# Targeted testing often finds issues with fewer examples\n$ st run openapi.yaml --max-examples=10000 --generation-maximize response_time\n</code></pre> <p>While results vary due to the random nature of property-based testing, targeted testing consistently improves efficiency on APIs with performance-related vulnerabilities.</p>"},{"location":"ci/github-actions/","title":"Using Schemathesis with GitHub Actions","text":"<p>This tutorial demonstrates how to integrate Schemathesis with GitHub Actions for automated API testing. The implementation uses a demo Flask application with intentional errors to showcase Schemathesis's capabilities in a CI environment.</p>"},{"location":"ci/github-actions/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of Docker and Python</li> <li>GitHub account</li> <li>Familiarity with GitHub Actions</li> </ul>"},{"location":"ci/github-actions/#setting-up-the-demo-environment","title":"Setting Up the Demo Environment","text":"<p>The demo repository contains a Flask application with several endpoints designed to trigger different types of API errors.</p> <pre><code>@app.route(\"/improper-unicode-encoding\", methods=[\"POST\"])\ndef improper_unicode_encoding():\n    data = request.json\n    if \"text\" not in data:\n        return jsonify({\"success\": False, \"error\": \"Missing text\"}), 400\n\n    try:\n        # Simulating improper Unicode handling\n        data[\"text\"].encode(\"ascii\")\n        return jsonify({\"success\": True})\n    except UnicodeEncodeError:\n        return jsonify({\"success\": False, \"error\": \"Unicode error\"}), 500\n</code></pre> <ol> <li> <p>Fork the demo repository to your GitHub account</p> </li> <li> <p>Clone your fork locally:</p> </li> </ol> <pre><code>$ git clone https://github.com/YOUR-USERNAME/schemathesis-demo.git\n$ cd schemathesis-demo\n</code></pre> <ol> <li>Start the application:</li> </ol> <pre><code>$ docker compose up -d\n</code></pre> <p>The API UI will be available at <code>http://127.0.0.1:5123/ui/</code></p>"},{"location":"ci/github-actions/#implementing-the-github-action","title":"Implementing the GitHub Action","text":"<p>The Schemathesis GitHub Action integrates API testing directly into your CI workflow.</p> <ol> <li>Create a new branch for the integration:</li> </ol> <pre><code>$ git checkout -b add-schemathesis-action\n</code></pre> <ol> <li>Create a workflow file at <code>.github/workflows/schemathesis.yml</code>:</li> </ol> <pre><code>name: Schemathesis Test\n\non: [pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Start containers\n      run: docker compose up -d --build\n\n    - uses: schemathesis/action@v1\n      with:\n        schema: 'http://127.0.0.1:5123/openapi.json'\n\n    - name: Stop containers\n      if: always()\n      run: docker-compose down\n</code></pre> <ol> <li>Commit and push your changes:</li> </ol> <pre><code>$ git add .github/workflows/schemathesis.yml\n$ git commit -m \"Add Schemathesis GitHub Action\"\n$ git push -u origin add-schemathesis-action\n</code></pre> <ol> <li>Open a pull request against your repository</li> </ol> <p>Note</p> <p>When opening the pull request, select your own repository as the base to ensure the workflow runs in your fork.</p> <p>The workflow will run when the PR is created, and Schemathesis will identify API issues:</p> <pre><code>________ POST /internal-server-errors/improper-unicode-encoding ________\n1. Test Case ID: F7IxDy\n\n- Server error\n\n[500] Internal Server Error:\n\n    `{\"error\":\"Unicode error\",\"success\":false}`\n\nReproduce with:\n\n    curl -X POST -H 'Content-Type: application/json' -d '{\"text\": \"\\u0080\"}' \n    http://127.0.0.1:5123/internal-server-errors/improper-unicode-encoding\n</code></pre>"},{"location":"ci/github-actions/#customizing-test-execution","title":"Customizing Test Execution","text":"<p>Customize the Schemathesis test run using action parameters:</p> <pre><code>- name: Set access token\n  run: echo \"TOKEN=super-secret\" &gt;&gt; $GITHUB_ENV\n\n- uses: schemathesis/action@v1\n  with:\n    schema: 'http://127.0.0.1:5123/openapi.json'\n    args: '-H \"Authorization: Bearer ${{ env.TOKEN }}\" --max-response-time=200'\n</code></pre> <p>This example adds an authorization header and sets a 200ms maximum response time threshold.</p> <p>For all available options, see the GitHub Action documentation.</p>"},{"location":"ci/gitlab-ci/","title":"GitLab CI Integration","text":"<p>This page shows how to run Schemathesis tests in GitLab CI/CD pipelines.</p>"},{"location":"ci/gitlab-ci/#basic-configuration","title":"Basic Configuration","text":"<p>Add this configuration to your <code>.gitlab-ci.yml</code> file:</p> <pre><code>api-tests:\n  stage: test\n  image:\n    name: schemathesis/schemathesis:stable\n    entrypoint: [\"\"]\n  script:\n    # Set up application here if needed\n    - st run http://127.0.0.1:5000/api/openapi.json\n</code></pre>"},{"location":"ci/overview/","title":"Continuous Integration","text":"<p>This guide explains how to integrate Schemathesis into CI/CD pipelines for automated API testing. Automated tests catch API regressions early and help maintain consistent API quality across releases.</p>"},{"location":"ci/overview/#general-integration-pattern","title":"General Integration Pattern","text":"<p>Schemathesis integration in CI follows this pattern:</p> <ol> <li>Start the API service.</li> <li>Wait for the API to become available.</li> <li>Run Schemathesis against the API schema.</li> <li>Process test results and generate reports.</li> </ol>"},{"location":"ci/overview/#schema-access-strategies","title":"Schema Access Strategies","text":""},{"location":"ci/overview/#url-based-schemas","title":"URL-Based Schemas","text":"<p>For APIs that expose their schema through an endpoint:</p> <pre><code>$ st run http://api-host:port/openapi.json\n</code></pre> <p>This approach ensures you're testing against the actual deployed schema but requires the API to be running.</p>"},{"location":"ci/overview/#file-based-schemas","title":"File-Based Schemas","text":"<p>For APIs with separately maintained schemas, run tests against a local schema file. Ensure the schema file is kept in sync with the API.</p> <pre><code>$ st run ./path/to/openapi.json --url http://api-host:port\n</code></pre> <p>This approach lets you test against a local schema file by specifying the target URL, ensuring tests run against the intended API.</p>"},{"location":"ci/overview/#using-configuration-files","title":"Using Configuration Files","text":"<p>For CI environments, create a dedicated configuration file (<code>schemathesis.toml</code>) with your testing settings. Schemathesis automatically loads this file from the current directory or project root.</p> <p>Since the config file supports environment variable substitution, you can use the same file across different environments by supplying different environment variables. To use a custom file, specify its path with <code>--config</code>.</p> <pre><code>[auth.openapi]\nApiKeyAuth = { value = \"${API_KEY}\" }\n\n[checks]\nresponse_schema_conformance.enabled = false\n\n[report.junit]\nenabled = \"${JUNIT_ENABLE}\"\npath = \"${JUNIT_REPORT_PATH}\"\n</code></pre> <p>Then in your CI workflow, simply reference this configuration:</p> <pre><code>$ st run http://api-host:port/openapi.json --config my-config.toml\n</code></pre> <p>Configuration Reference</p> <p>See the Configuration Guide for usage instructions and the Configuration Reference for all available options.</p>"},{"location":"ci/overview/#exit-codes","title":"Exit Codes","text":"<p>Schemathesis returns these exit codes that you should handle in your CI job:</p> <ul> <li><code>0</code>: All tests passed</li> <li><code>1</code>: Tests failed</li> <li><code>2</code>: Invalid schema or configuration error</li> </ul>"},{"location":"ci/overview/#platform-specific-integration","title":"Platform-Specific Integration","text":"<p>For detailed setup instructions on specific CI platforms:</p> <ul> <li>GitHub Actions</li> <li>GitLab CI</li> </ul> <p>Each platform guide includes concrete examples, authentication patterns, and troubleshooting advice specific to that environment.</p>"},{"location":"extending/auth/","title":"Authentication","text":""},{"location":"extending/checks/","title":"Checks","text":""},{"location":"extending/data-generation/","title":"Data Generation","text":""},{"location":"extending/hooks/","title":"Hooks","text":""},{"location":"extending/overview/","title":"Extending Schemathesis","text":""},{"location":"openapi/examples/","title":"Examples in API Schemas","text":"<p>Schema examples in OpenAPI are predefined sample values for request parameters and bodies. They serve as concrete test cases to validate that the API handles typical inputs correctly.</p> <p>Schemathesis supports these distinct testing paradigms:</p> <ul> <li>Example-based testing: Uses fixed input values from your schema to produce predictable, repeatable tests.</li> <li>Property-based testing: Generates a diverse range of inputs dynamically to expose unexpected edge cases.</li> </ul> <p>Use schema examples to verify critical business logic, ensure backward compatibility, and achieve deterministic test reproduction. In contrast, property-based testing is ideal for discovering unexpected edge cases and performance issues.</p>"},{"location":"openapi/examples/#defining-examples-in-openapi","title":"Defining Examples in OpenAPI","text":"<p>In OpenAPI 3.0+, use <code>example</code> for a single example and <code>examples</code> for multiple values. You can define examples at both the property and operation levels, or reference external files using <code>externalValue</code>.</p> <pre><code># Single example using the 'example' keyword\nschema:\n  type: object\n  properties:\n    name:\n      type: string\n      example: \"John Doe\"\n</code></pre> <pre><code># Multiple examples using the 'examples' keyword (OpenAPI 3.0+)\nschema:\n  type: object\n  properties:\n    name:\n      type: string\n      examples:\n        - \"John Doe\"\n        - \"Jane Smith\"\n</code></pre> <pre><code># Property-level example\nproperties:\n  name:\n    type: string\n    example: \"John Doe\"\n  age:\n    type: integer\n    example: 30\n</code></pre> <pre><code># Operation-level example\nrequestBody:\n  content:\n    application/json:\n      schema:\n        $ref: '#/components/schemas/User'\n      example:\n        name: \"John Doe\"\n        age: 30\n</code></pre> <pre><code>content:\n  application/json:\n    schema:\n      $ref: '#/components/schemas/User'\n    examples:\n      user:\n        summary: \"A typical user\"\n        externalValue: 'http://example.com/examples/user.json'\n</code></pre> <p>Schemathesis will load and cache external examples during testing.</p> <p>OpenAPI 2.0 Support</p> <p>In OpenAPI 2.0, use the <code>example</code> keyword or <code>x-examples</code> extension for multiple examples.</p> <pre><code># OpenAPI 2.0 with multiple examples\ndefinitions:\n  User:\n    type: object\n    properties:\n      name:\n        type: string\n    x-examples:\n      - name: \"John Doe\"\n      - name: \"Jane Smith\"\n</code></pre>"},{"location":"openapi/examples/#using-examples-in-tests","title":"Using Examples in Tests","text":"<p>Schemathesis automatically detects schema examples and uses them as test cases. For parameters without examples, it generates minimal valid values to ensure every operation is tested.</p> <pre><code># Schema\nschema:\n  type: object\n  properties:\n    name:\n      type: string\n      example: \"John\"\n    age:\n      type: integer\n    address:\n      type: string\n</code></pre> <p>This would generate test cases like:</p> <pre><code>{\"name\": \"John\", \"age\": 42, \"address\": \"abc\"}\n</code></pre> <p>Where <code>\"John\"</code> comes from the example, while the other values are minimal values that satisfy the schema constraints.</p>"},{"location":"openapi/examples/#command-line-interface","title":"Command-Line Interface","text":"<p>Run example-based tests only using the <code>--phases=examples</code> option:</p> <pre><code>$ st run --phases=examples https://example.schemathesis.io/openapi.json\n</code></pre> <p>This restricts testing to the examples phase, skipping other testing phases like coverage, fuzzing, and stateful testing.</p>"},{"location":"openapi/examples/#handling-missing-examples","title":"Handling Missing Examples","text":"<p>For API operations that don't have any examples defined, you can use the <code>generation.fill-missing-examples</code> configuration option:</p> <pre><code># schemathesis.toml\n[generation]\nfill-missing-examples = true\n</code></pre> <p>This generates one simple example per operation that lacks examples, ensuring all operations are tested in the examples phase.</p>"},{"location":"openapi/examples/#multiple-examples-strategy","title":"Multiple Examples Strategy","text":"<p>Schemathesis uses a round-robin strategy to evenly distribute test cases across multiple examples:</p> <pre><code># Schema\nproperties:\n  name:\n    type: string\n    example: \"John\"\n  age:\n    type: integer\n    examples: [25, 30, 35]\n</code></pre> <p>Schemathesis will generate test cases using each age value: <pre><code>{\"name\": \"John\", \"age\": 25, ...}\n{\"name\": \"John\", \"age\": 30, ...}\n{\"name\": \"John\", \"age\": 35, ...}\n</code></pre></p>"},{"location":"openapi/examples/#differences-with-dredd","title":"Differences with Dredd","text":"<p>Unlike Dredd, which depends exclusively on schema examples for generating test cases, Schemathesis employs a hybrid approach. It treats predefined examples as fixed test inputs while also dynamically generating additional inputs to explore the broader input space. This allows for both deterministic validation of documented scenarios and exploration of potential edge cases. Furthermore, Schemathesis supports test case reduction and stateful testing to isolate minimal failing inputs and validate complex operation sequences.</p> <p>Feedback</p> <p>If you rely on Dredd and find that a particular feature is missing in Schemathesis, please share your feedback via GitHub Discussions.</p>"},{"location":"reference/checks/","title":"Checks","text":""},{"location":"reference/cli/","title":"Schemathesis CLI Reference","text":"<p>This reference details all the command-line options available in the Schemathesis CLI. The documentation is organized by command and subcommand to provide a clear structure of available options and their usage.</p>"},{"location":"reference/cli/#global-options","title":"Global Options","text":"<p>These options apply to all Schemathesis commands:</p>"},{"location":"reference/cli/#-no-color","title":"<code>--no-color</code>","text":"<p>Disables ANSI color output in the terminal. Use this option when running in environments where color codes may cause issues or when redirecting output to files.</p>"},{"location":"reference/cli/#-force-color","title":"<code>--force-color</code>","text":"<p>Forces the use of ANSI color escape codes in terminal output, even in environments where Schemathesis would normally disable colors.</p>"},{"location":"reference/cli/#run","title":"<code>run</code>","text":"<p>The <code>run</code> command executes API tests against an API using a schema for test generation.</p> <pre><code>$ st run [OPTIONS] SCHEMA\n</code></pre> <p>Required Parameter</p> <p>SCHEMA: Path to an OpenAPI (<code>.json</code>, <code>.yml</code>) or GraphQL SDL file, or a URL pointing to such specifications. This schema defines the API surface to test.</p>"},{"location":"reference/cli/#basic-options","title":"Basic Options","text":""},{"location":"reference/cli/#-u-url-url","title":"<code>-u, --url URL</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>Specifies the base URL for the API under test. Required for file-based schemas.</p> <pre><code>$ st run openapi.yaml --url https://api.example.com\n</code></pre>"},{"location":"reference/cli/#-w-workers-value","title":"<code>-w, --workers VALUE</code>","text":"<p>Type: <code>Integer or \"auto\"</code> Default: <code>auto</code> Range: <code>1-64</code> or <code>auto</code> </p> <p>Specifies the number of concurrent workers for running unit test phases (examples, coverage, fuzzing). Use \"auto\" to automatically adjust based on available CPU cores.</p> <pre><code>$ st run openapi.yaml --workers 4\n</code></pre>"},{"location":"reference/cli/#-phases-phases","title":"<code>--phases PHASES</code>","text":"<p>Type: <code>Comma-separated list</code> Default: All phases enabled Possible values: <code>examples</code>, <code>coverage</code>, <code>fuzzing</code>, <code>stateful</code> </p> <p>Specifies which test phases to run.</p> <pre><code>$ st run openapi.yaml --phases examples,fuzzing\n</code></pre>"},{"location":"reference/cli/#-suppress-health-check-checks","title":"<code>--suppress-health-check CHECKS</code>","text":"<p>Type: <code>Comma-separated list</code> Default: <code>[]</code> Possible values: <code>data_too_large</code>, <code>filter_too_much</code>, <code>too_slow</code>, <code>large_base_example</code>, <code>all</code> </p> <p>Disables specified health checks during test execution. Health checks identify potential problems with test generation or performance and may stop tests early with an error to prevent Schemathesis from hanging (e.g., when processing extremely complex schemas).</p> <pre><code>$ st run openapi.yaml --suppress-health-check too_slow,data_too_large\n</code></pre>"},{"location":"reference/cli/#-wait-for-schema-seconds","title":"<code>--wait-for-schema SECONDS</code>","text":"<p>Type: <code>Float</code> Default: <code>null</code> Range: <code>\u22651.0</code> </p> <p>Maximum time in seconds to wait for the API schema to become available. Useful when testing services that take time to start up.</p> <pre><code>$ st run https://api.example.com/openapi.json --wait-for-schema 5.0\n</code></pre>"},{"location":"reference/cli/#validation","title":"Validation","text":""},{"location":"reference/cli/#-c-checks-checks","title":"<code>-c, --checks CHECKS</code>","text":"<p>Type: <code>Comma-separated list</code> Default: All checks enabled Possible values: <code>not_a_server_error</code>, <code>status_code_conformance</code>, <code>content_type_conformance</code>, <code>response_headers_conformance</code>, <code>response_schema_conformance</code>, <code>negative_data_rejection</code>, <code>positive_data_acceptance</code>, <code>use_after_free</code>, <code>ensure_resource_availability</code>, <code>ignored_auth</code>, <code>all</code> </p> <p>Specifies which checks to run against API responses.</p> <pre><code>$ st run openapi.yaml --checks not_a_server_error,response_schema_conformance\n</code></pre>"},{"location":"reference/cli/#-exclude-checks-checks","title":"<code>--exclude-checks CHECKS</code>","text":"<p>Type: <code>Comma-separated list</code> Default: <code>[]</code> Possible values: <code>not_a_server_error</code>, <code>status_code_conformance</code>, <code>content_type_conformance</code>, <code>response_headers_conformance</code>, <code>response_schema_conformance</code>, <code>negative_data_rejection</code>, <code>positive_data_acceptance</code>, <code>use_after_free</code>, <code>ensure_resource_availability</code>, <code>ignored_auth</code>, <code>all</code> </p> <p>Specifies which checks to skip during testing.</p> <pre><code>$ st run openapi.yaml --checks all --exclude-checks response_schema_conformance\n</code></pre>"},{"location":"reference/cli/#-max-failures-count","title":"<code>--max-failures COUNT</code>","text":"<p>Type: <code>Integer</code> Default: <code>null</code> Range: <code>\u22651</code> </p> <p>Terminates the test suite after reaching a specified number of failures or errors.</p> <pre><code>$ st run openapi.yaml --max-failures 5\n</code></pre>"},{"location":"reference/cli/#-continue-on-failure","title":"<code>--continue-on-failure</code>","text":"<p>Type: <code>Flag</code> Default: <code>false</code> </p> <p>When enabled, continues executing all test cases within a scenario, even after encountering failures.</p> <pre><code>$ st run openapi.yaml --continue-on-failure\n</code></pre>"},{"location":"reference/cli/#-max-response-time-seconds","title":"<code>--max-response-time SECONDS</code>","text":"<p>Type: <code>Float</code> Default: <code>null</code> Range: <code>&gt;0.0</code> </p> <p>Maximum allowed API response time in seconds. Responses exceeding this limit will be reported as failures.</p> <pre><code>$ st run openapi.yaml --max-response-time 2.5\n</code></pre>"},{"location":"reference/cli/#filtering","title":"Filtering","text":"<p>Schemathesis provides various ways to filter which operations are tested:</p>"},{"location":"reference/cli/#-include-type-value-exclude-type-value","title":"<code>--include-TYPE VALUE</code> / <code>--exclude-TYPE VALUE</code>","text":"<p>Type: <code>String</code> </p> <p>Include or exclude operations by exact match on path, method, tag, or operation-id.</p> <pre><code>$ st run openapi.yaml --include-tag users\n$ st run openapi.yaml --exclude-method DELETE\n</code></pre>"},{"location":"reference/cli/#-include-type-regex-pattern-exclude-type-regex-pattern","title":"<code>--include-TYPE-regex PATTERN</code> / <code>--exclude-TYPE-regex PATTERN</code>","text":"<p>Type: <code>String (regex pattern)</code> </p> <p>Include or exclude operations matching a regular expression pattern on path, method, tag, or operation-id.</p> <pre><code>$ st run openapi.yaml --include-path-regex \"/api/v1/.*\"\n$ st run openapi.yaml --exclude-tag-regex \"admin|internal\"\n</code></pre>"},{"location":"reference/cli/#-include-by-expr-exclude-by-expr","title":"<code>--include-by EXPR</code> / <code>--exclude-by EXPR</code>","text":"<p>Type: <code>String (expression)</code> </p> <p>Include or exclude operations using a custom expression. The expression must start with a JSON Pointer.</p> <pre><code>$ st run openapi.yaml --include-by \"/tags/0 == 'user'\"\n</code></pre>"},{"location":"reference/cli/#-exclude-deprecated","title":"<code>--exclude-deprecated</code>","text":"<p>Type: <code>Flag</code> Default: <code>false</code> </p> <p>Skip deprecated API operations.</p> <pre><code>$ st run openapi.yaml --exclude-deprecated\n</code></pre>"},{"location":"reference/cli/#network","title":"Network","text":"<p>The following options control how Schemathesis makes network requests to the API under test:</p>"},{"location":"reference/cli/#-h-header-namevalue","title":"<code>-H, --header NAME:VALUE</code>","text":"<p>Type: <code>String (multiple allowed)</code> </p> <p>Add custom HTTP headers to all API requests. This option can be specified multiple times.</p> <pre><code>$ st run openapi.yaml \\\n  --header \"X-API-Key: abcdef123456\" \\\n  --header \"Accept-Language: en-US\"\n</code></pre>"},{"location":"reference/cli/#-a-auth-userpass","title":"<code>-a, --auth USER:PASS</code>","text":"<p>Type: <code>String</code> </p> <p>Authenticate all API requests with basic authentication.</p> <pre><code>$ st run openapi.yaml --auth username:password\n</code></pre>"},{"location":"reference/cli/#-proxy-url","title":"<code>--proxy URL</code>","text":"<p>Type: <code>String</code> </p> <p>Set the proxy for all network requests.</p> <pre><code>$ st run openapi.yaml --proxy http://localhost:8080\n</code></pre>"},{"location":"reference/cli/#-tls-verify-text","title":"<code>--tls-verify TEXT</code>","text":"<p>Type: <code>String or Boolean</code> Default: <code>true</code> </p> <p>Path to CA bundle for TLS verification, or 'false' to disable TLS verification.</p> <pre><code>$ st run openapi.yaml --tls-verify false\n$ st run openapi.yaml --tls-verify /path/to/ca-bundle.pem\n</code></pre>"},{"location":"reference/cli/#-rate-limit-text","title":"<code>--rate-limit TEXT</code>","text":"<p>Type: <code>String</code> Format: <code>&lt;limit&gt;/&lt;duration&gt;</code> </p> <p>Specify a rate limit for test requests. Supports 's' (seconds), 'm' (minutes), and 'h' (hours) as duration units.</p> <pre><code>$ st run openapi.yaml --rate-limit 100/m\n$ st run openapi.yaml --rate-limit 5/s\n</code></pre>"},{"location":"reference/cli/#-request-timeout-seconds","title":"<code>--request-timeout SECONDS</code>","text":"<p>Type: <code>Float</code> Range: <code>&gt;0.0</code> </p> <p>Timeout limit, in seconds, for each network request during tests.</p> <pre><code>$ st run openapi.yaml --request-timeout 5.0\n</code></pre>"},{"location":"reference/cli/#-request-cert-path","title":"<code>--request-cert PATH</code>","text":"<p>Type: <code>String (file path)</code> </p> <p>File path of unencrypted client certificate for authentication. The certificate can be bundled with a private key (e.g., PEM) or used with a separate private key.</p> <pre><code>$ st run openapi.yaml --request-cert /path/to/client-cert.pem\n</code></pre>"},{"location":"reference/cli/#-request-cert-key-path","title":"<code>--request-cert-key PATH</code>","text":"<p>Type: <code>String (file path)</code> </p> <p>Specify the file path of the private key for the client certificate when not bundled together.</p> <pre><code>$ st run openapi.yaml \\\n  --request-cert /path/to/client-cert.crt \\\n  --request-cert-key /path/to/private-key.key\n</code></pre>"},{"location":"reference/cli/#output","title":"Output","text":"<p>These options control the reporting and output format of test results:</p>"},{"location":"reference/cli/#-report-format","title":"<code>--report FORMAT</code>","text":"<p>Type: <code>Comma-separated list</code> Possible values: <code>junit</code>, <code>vcr</code>, <code>har</code> </p> <p>Generate test reports in specified formats as a comma-separated list.</p> <pre><code>$ st run openapi.yaml --report junit,har\n</code></pre>"},{"location":"reference/cli/#-report-dir-directory","title":"<code>--report-dir DIRECTORY</code>","text":"<p>Type: <code>String</code> Default: <code>schemathesis-report</code> </p> <p>Directory to store all report files.</p> <pre><code>$ st run openapi.yaml --report junit --report-dir ./test-reports\n</code></pre>"},{"location":"reference/cli/#-report-junit-path-filename","title":"<code>--report-junit-path FILENAME</code>","text":"<p>Type: <code>String</code> </p> <p>Custom path for JUnit XML report.</p> <pre><code>$ st run openapi.yaml --report junit --report-junit-path ./custom-junit.xml\n</code></pre>"},{"location":"reference/cli/#-report-vcr-path-filename","title":"<code>--report-vcr-path FILENAME</code>","text":"<p>Type: <code>String</code> </p> <p>Custom path for VCR cassette.</p> <pre><code>$ st run openapi.yaml --report vcr --report-vcr-path ./custom-vcr.yaml\n</code></pre>"},{"location":"reference/cli/#-report-har-path-filename","title":"<code>--report-har-path FILENAME</code>","text":"<p>Type: <code>String</code> </p> <p>Custom path for HAR file.</p> <pre><code>$ st run openapi.yaml --report har --report-har-path ./custom-har.json\n</code></pre>"},{"location":"reference/cli/#-report-preserve-bytes","title":"<code>--report-preserve-bytes</code>","text":"<p>Type: <code>Flag</code> Default: <code>false</code> </p> <p>Retain exact byte sequence of payloads in cassettes, encoded as base64.</p> <pre><code>$ st run openapi.yaml --report vcr --report-preserve-bytes\n</code></pre>"},{"location":"reference/cli/#-output-sanitize-boolean","title":"<code>--output-sanitize BOOLEAN</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Enable or disable automatic output sanitization to obscure sensitive data.</p> <pre><code>$ st run openapi.yaml --output-sanitize false\n</code></pre>"},{"location":"reference/cli/#-output-truncate-boolean","title":"<code>--output-truncate BOOLEAN</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Truncate schemas and responses in error messages for improved readability.</p> <pre><code>$ st run openapi.yaml --output-truncate false\n</code></pre>"},{"location":"reference/cli/#data-generation","title":"Data Generation","text":"<p>These options control how Schemathesis generates test data for API testing:</p>"},{"location":"reference/cli/#-m-mode-mode","title":"<code>-m, --mode MODE</code>","text":"<p>Type: <code>String</code> Default: <code>positive</code> Possible values: <code>positive</code>, <code>negative</code>, <code>all</code> </p> <p>Test data generation mode. Controls whether Schemathesis generates valid data, invalid data, or both.</p> <pre><code>$ st run openapi.yaml --mode all\n</code></pre>"},{"location":"reference/cli/#-n-max-examples-count","title":"<code>-n, --max-examples COUNT</code>","text":"<p>Type: <code>Integer</code> Range: <code>\u22651</code> </p> <p>Maximum number of test cases per API operation.</p> <pre><code>$ st run openapi.yaml --max-examples 100\n</code></pre>"},{"location":"reference/cli/#-seed-integer","title":"<code>--seed INTEGER</code>","text":"<p>Type: <code>Integer</code> </p> <p>Random seed for reproducible test runs. Setting the same seed value will result in the same sequence of generated test cases.</p> <pre><code>$ st run openapi.yaml --seed 42\n</code></pre>"},{"location":"reference/cli/#-no-shrink","title":"<code>--no-shrink</code>","text":"<p>Type: <code>Flag</code> Default: <code>false</code> </p> <p>Disable test case shrinking. Makes test failures harder to debug but improves performance.</p> <pre><code>$ st run openapi.yaml --no-shrink\n</code></pre>"},{"location":"reference/cli/#-generation-deterministic","title":"<code>--generation-deterministic</code>","text":"<p>Type: <code>Flag</code> Default: <code>false</code> </p> <p>Enables deterministic mode, which eliminates random variation between tests.</p> <pre><code>$ st run openapi.yaml --generation-deterministic\n</code></pre>"},{"location":"reference/cli/#-generation-allow-x00-boolean","title":"<code>--generation-allow-x00 BOOLEAN</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Whether to allow the generation of 'NULL' bytes within strings.</p> <pre><code>$ st run openapi.yaml --generation-allow-x00 false\n</code></pre>"},{"location":"reference/cli/#-generation-codec-text","title":"<code>--generation-codec TEXT</code>","text":"<p>Type: <code>String</code> </p> <p>The codec used for generating strings. Defines the character encoding for string generation.</p> <pre><code>$ st run openapi.yaml --generation-codec ascii\n</code></pre>"},{"location":"reference/cli/#-generation-maximize-metric","title":"<code>--generation-maximize METRIC</code>","text":"<p>Type: <code>String</code> Possible values: <code>response_time</code> </p> <p>Guide input generation to values more likely to expose bugs via targeted property-based testing.</p> <pre><code>$ st run openapi.yaml --generation-maximize response_time\n</code></pre>"},{"location":"reference/cli/#-generation-with-security-parameters-boolean","title":"<code>--generation-with-security-parameters BOOLEAN</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Whether to generate security parameters during testing.</p> <pre><code>$ st run openapi.yaml --generation-with-security-parameters false\n</code></pre>"},{"location":"reference/cli/#-generation-graphql-allow-null-boolean","title":"<code>--generation-graphql-allow-null BOOLEAN</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Whether to use <code>null</code> values for optional arguments in GraphQL queries. Applicable only for GraphQL API testing.</p> <pre><code>$ st run openapi.yaml --generation-graphql-allow-null false\n</code></pre>"},{"location":"reference/cli/#-generation-database-text","title":"<code>--generation-database TEXT</code>","text":"<p>Type: <code>String</code> Default: <code>.hypothesis/examples</code> </p> <p>Storage for examples discovered by Schemathesis. Use <code>none</code> to disable, <code>:memory:</code> for temporary storage, or specify a file path for persistent storage.</p> <pre><code>$ st run openapi.yaml --generation-database \":memory:\"\n$ st run openapi.yaml --generation-database ./schemathesis_examples.db\n</code></pre>"},{"location":"reference/cli/#-generation-unique-inputs","title":"<code>--generation-unique-inputs</code>","text":"<p>Type: <code>Flag</code> Default: <code>false</code> </p> <p>Force the generation of unique test cases. When enabled, Schemathesis will ensure that no duplicate test inputs are used within a single test phase.</p> <pre><code>$ st run openapi.yaml --generation-unique-inputs\n</code></pre>"},{"location":"reference/configuration/","title":"Configuration Options","text":"<p>This reference details all the configuration options available in <code>schemathesis.toml</code>. The settings are organized into two main categories:</p> <ul> <li>Global: These control CLI behavior, output formatting, and overall test execution. They are defined at the top level and affect the CLI invocation.</li> <li>Per-Project: These let you customize configurations for individual API projects. If project-level settings are placed at the top level (without a <code>[project.&lt;name&gt;]</code> namespace), they are applied to the \"default\" project.</li> </ul> <p>This structure simplifies single-project setups by allowing you to specify project-level settings directly at the top level while still providing the flexibility to override them for specific projects.</p>"},{"location":"reference/configuration/#configuration-resolution","title":"Configuration Resolution","text":"<p>Schemathesis applies settings in the following hierarchy (from highest to lowest precedence):</p> <ol> <li>CLI options</li> <li>Operation-specific phase settings (e.g., <code>[operation.\"GET /users\".phases.fuzzing]</code>)</li> <li>Global phase settings (e.g., <code>[phases.fuzzing]</code>)</li> <li>Operation-level settings (e.g., <code>[operation.\"GET /users\"]</code>)</li> <li>Project-level settings (e.g., <code>[projects.payments]</code>)</li> <li>Global settings (top level)</li> </ol> <p>This hierarchy allows you to set sensible defaults at higher levels while overriding specific settings as needed.</p>"},{"location":"reference/configuration/#environment-variable-substitution","title":"Environment Variable Substitution","text":"<p>Schemathesis supports using environment variables in configuration files with the <code>${VAR_NAME}</code> syntax:</p> <pre><code>base-url = \"https://${API_HOST}/v1\"\nheaders = { \"Authorization\" = \"Bearer ${API_TOKEN}\" }\n</code></pre> <p>This allows you to maintain a single configuration file across different environments by changing environment variables rather than the configuration itself.</p>"},{"location":"reference/configuration/#operation-targeting","title":"Operation Targeting","text":"<p>Schemathesis allows targeting specific API operations in three ways:</p> <ul> <li>By exact path: <code>[operation.\"GET /users\"]</code></li> <li>By regex pattern: <code>[operation.regex.\"GET /users/.*\"]</code></li> <li>By tag: <code>[operation.tag.\"admin\"]</code></li> <li>By expression: <code>[operation.expr.\"tags/0 == 'user'\"]</code></li> </ul> <p>When multiple selectors match an operation, they're applied in the order: exact path (highest precedence), tag, expression, regex (lowest precedence).</p>"},{"location":"reference/configuration/#parameter-overrides","title":"Parameter Overrides","text":"<p>Parameters can be overridden at the global or operation level:</p> <pre><code># Global parameters\n[parameters]\n\"api_version\" = \"v2\"\n\n# Operation-specific parameters\n[operation.\"GET /users\"]\nparameters = { \"limit\" = 50, \"offset\" = 0 }\n\n# Disambiguate parameters with the same name\nparameters = { \"path.user_id\" = 42, \"query.user_id\" = 100 }\n</code></pre>"},{"location":"reference/configuration/#global-settings","title":"Global Settings","text":""},{"location":"reference/configuration/#color","title":"<code>color</code>","text":"<p>Type: <code>Boolean or None</code> Default: <code>null</code> </p> <p>Controls ANSI color output in the CLI. Schemathesis auto-detects color support by default. Set to <code>true</code> to force color output or <code>false</code> to disable it.</p> <pre><code>color = false\n</code></pre>"},{"location":"reference/configuration/#suppress-health-check","title":"<code>suppress-health-check</code>","text":"<p>Type: <code>Array of strings</code> Default: <code>[]</code> </p> <p>Specifies a list of health checks to disable during test execution. Possible values include: <code>data_too_large</code>, <code>filter_too_much</code>, <code>too_slow</code>, <code>large_base_example</code>, and <code>all</code>.</p> <pre><code>suppress-health-check = [\"too_slow\", \"data_too_large\"]\n</code></pre>"},{"location":"reference/configuration/#max-failures","title":"<code>max-failures</code>","text":"<p>Type: <code>Integer (\u22651)</code> Default: <code>Not set</code> </p> <p>Terminates the test run after the specified number of failures is reached.</p> <pre><code>max-failures = 42\n</code></pre>"},{"location":"reference/configuration/#reporting","title":"Reporting","text":""},{"location":"reference/configuration/#reportdirectory","title":"<code>report.directory</code>","text":"<p>Type: <code>String</code> Default: <code>\"schemathesis-report\"</code> </p> <p>Specifies the directory where all test reports are stored.</p> <pre><code>[report]\ndirectory = \"schemathesis-report\"\n</code></pre>"},{"location":"reference/configuration/#reportpreserve-bytes","title":"<code>report.preserve-bytes</code>","text":"<p>Type: <code>Boolean</code> Default: <code>false</code> </p> <p>Retains the exact byte sequences of payloads in reports, encoded as base64 when enabled.</p> <pre><code>[report]\npreserve-bytes = true\n</code></pre>"},{"location":"reference/configuration/#reportformatenabled","title":"<code>report.&lt;format&gt;.enabled</code>","text":"<p>Type: <code>Boolean</code> Default: <code>false</code> </p> <p>Enables the generation of the specified report format. Replace <code>&lt;format&gt;</code> with one of: <code>junit</code>, <code>vcr</code>, or <code>har</code>.</p> <pre><code>[report.junit]\nenabled = true\n</code></pre>"},{"location":"reference/configuration/#reportformatpath","title":"<code>report.&lt;format&gt;.path</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>Specifies a custom path for the report of the specified format. Replace <code>&lt;format&gt;</code> with one of: <code>junit</code>, <code>vcr</code>, or <code>har</code>.</p> <pre><code>[report.junit]\npath = \"./test-reports/schemathesis-results.xml\"\n</code></pre>"},{"location":"reference/configuration/#output","title":"Output","text":""},{"location":"reference/configuration/#outputsanitize","title":"<code>output.sanitize</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Controls automatic sanitization of output data to obscure sensitive information.</p> <pre><code>[output]\nsanitize = false\n</code></pre>"},{"location":"reference/configuration/#outputtruncate","title":"<code>output.truncate</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Truncates long output in error messages for improved readability.</p> <pre><code>[output]\ntruncate = false\n</code></pre>"},{"location":"reference/configuration/#project-settings","title":"Project Settings","text":"<p>These settings can only be applied at the project level.</p>"},{"location":"reference/configuration/#base-url","title":"<code>base-url</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>Sets the base URL for the API under test. This setting is required when testing with a file-based schema.</p> <pre><code># Optionally under a named project\n# [project.payments]\nbase-url = \"https://api.example.com\"\n</code></pre>"},{"location":"reference/configuration/#hooks","title":"<code>hooks</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>Specifies a Python module path where custom hooks for extending Schemathesis functionality are located. This allows you to define custom checks, adjust data generation, or extend CLI.</p> <pre><code># Global hooks for all projects\nhooks = \"myproject.tests.hooks\"\n\n# Or project-specific hooks\n[projects.payments]\nhooks = \"myproject.payments.hooks\"\n</code></pre>"},{"location":"reference/configuration/#workers","title":"<code>workers</code>","text":"<p>Type: <code>Integer or \"auto\"</code> Default: <code>1</code> </p> <p>Specifies the number of concurrent workers for running unit test phases.</p> <pre><code>workers = \"auto\"  # Auto-adjust based on available cores\nworkers = 4       # Use exactly 4 workers\n</code></pre>"},{"location":"reference/configuration/#wait-for-schema","title":"<code>wait-for-schema</code>","text":"<p>Type: <code>Number (\u22651.0)</code> Default: <code>null</code> </p> <p>Maximum duration, in seconds, to wait for the API schema to become available. Useful when testing services that take time to start up.</p> <pre><code>wait-for-schema = 5.0\n</code></pre>"},{"location":"reference/configuration/#exclude-deprecated","title":"<code>exclude-deprecated</code>","text":"<p>Type: <code>Boolean</code> Default: <code>false</code> </p> <p>Skip deprecated API operations.</p> <pre><code>exclude-deprecated = true\n</code></pre>"},{"location":"reference/configuration/#continue-on-failure","title":"<code>continue-on-failure</code>","text":"<p>Type: <code>Boolean</code> Default: <code>false</code> </p> <p>When enabled, continues executing all test cases within a scenario, even after encountering failures.</p> <pre><code>continue-on-failure = true\n</code></pre>"},{"location":"reference/configuration/#max-response-time","title":"<code>max-response-time</code>","text":"<p>Type: <code>Float (&gt;0)</code> Default: <code>null</code> </p> <p>Maximum allowed API response time in seconds. Responses exceeding this limit will be reported as failures.</p> <pre><code>max-response-time = 2.0\n</code></pre>"},{"location":"reference/configuration/#phasesphaseenabled","title":"<code>phases.&lt;phase&gt;.enabled</code>","text":"<p>Type: <code>Boolean</code> Default: <code>false</code> </p> <p>Enables a testing phase. Replace <code>&lt;phase&gt;</code> with one of: <code>examples</code>, <code>coverage</code>, <code>fuzzing</code>, or <code>stateful</code>.</p> <pre><code>[phases.coverage]\nenabled = true\n</code></pre>"},{"location":"reference/configuration/#authentication","title":"Authentication","text":""},{"location":"reference/configuration/#authbasic","title":"<code>auth.basic</code>","text":"<p>Type: <code>Object</code> Default: <code>null</code> </p> <p>Provides basic authentication credentials. Define this object with <code>username</code> and <code>password</code> keys. This setting corresponds to the <code>--auth</code> CLI option.</p> <pre><code>[auth]\nbasic = { username = \"${USERNAME}\", password = \"${PASSWORD}\" }\n</code></pre>"},{"location":"reference/configuration/#authbearer","title":"<code>auth.bearer</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>Specifies a bearer token for authentication. This token can alternatively be provided via CLI headers.</p> <pre><code>[auth]\nbearer = \"${TOKEN}\"\n</code></pre>"},{"location":"reference/configuration/#authopenapi","title":"<code>auth.openapi</code>","text":"<p>Type: <code>Object</code> Default: <code>null</code> </p> <p>Defines authentication settings for OpenAPI security schemes. Each key in this object should match a security scheme defined in your OpenAPI specification. Schemathesis resolves authentication in order: CLI options, operation headers, OpenAPI-specific authentication, and then generic authentication.</p> <pre><code>[auth.openapi]\n# Basic HTTP authentication\nBasicAuth = { username = \"${USERNAME}\", password = \"${PASSWORD}\" }\n\n# Bearer token authentication\nBearerAuth = { token = \"${TOKEN}\" }\n\n# API Key authentication\nApiKeyAuth = { value = \"${API_KEY}\" }\n\n# OAuth2 authentication\nOAuth2 = { \n  client_id = \"${CLIENT_ID}\", \n  client_secret = \"${CLIENT_SECRET}\",\n  scopes = [\"read\", \"write\"]\n}\n</code></pre>"},{"location":"reference/configuration/#checks","title":"Checks","text":""},{"location":"reference/configuration/#checkscheckenabled","title":"<code>checks.&lt;check&gt;.enabled</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Enables or disables the specified check. Replace <code>&lt;check&gt;</code> with the name of the check (for example, <code>not_a_server_error</code>, <code>status_code_conformance</code>, <code>content_type_conformance</code>, <code>response_schema_conformance</code>, <code>positive_data_acceptance</code>, <code>negative_data_rejection</code>, <code>use_after_free</code>, <code>ensure_resource_availability</code>, <code>missing_required_header</code>, or <code>ignored_auth</code>).</p> <pre><code>[checks]\nresponse_schema_conformance.enabled = false\n</code></pre>"},{"location":"reference/configuration/#checkscheckexpected-statuses","title":"<code>checks.&lt;check&gt;.expected-statuses</code>","text":"<p>Type: <code>Array of integers</code> Default: <code>[200]</code> </p> <p>Defines the HTTP status codes expected from the API for specific checks. Different checks may interpret this setting differently:</p> <pre><code>- For `positive_data_acceptance`: Defines status codes that indicate the API has accepted valid data\n- For `negative_data_rejection`: Defines status codes that indicate the API has properly rejected invalid data\n- For `missing_required_header`: Defines status codes that indicate the API has properly rejected a call without required header\n- For `not_a_server_error`: Defines status codes that are not considered server errors within the 5xx range\n\nThis allows you to customize validation for APIs that use non-standard success or error codes.\n</code></pre> <pre><code>[checks]\npositive_data_acceptance.expected-statuses = [200, 201, 202]\n</code></pre>"},{"location":"reference/configuration/#network","title":"Network","text":"<p>The following settings control how Schemathesis makes network requests to the API under test.</p>"},{"location":"reference/configuration/#header","title":"<code>header</code>","text":"<p>Type: <code>Object</code> Default: <code>{}</code> </p> <p>Add custom HTTP headers to all API requests. Headers are specified as key-value pairs.</p> <pre><code># Add a single header\nheader = { \"X-API-Key\" = \"${API_KEY}\" }\n\n# Add multiple headers\nheader = { \"X-API-Key\" = \"${API_KEY}\", \"Accept-Language\" = \"en-US\" }\n</code></pre>"},{"location":"reference/configuration/#proxy","title":"<code>proxy</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>Set the proxy URL for all network requests. Supports HTTP and HTTPS proxies.</p> <pre><code># HTTP proxy\nproxy = \"http://localhost:8080\"\n\n# HTTPS proxy with authentication\nproxy = \"https://user:password@proxy.example.com:8443\"\n</code></pre>"},{"location":"reference/configuration/#tls-verify","title":"<code>tls-verify</code>","text":"<p>Type: <code>String | Boolean</code> Default: <code>true</code> </p> <p>Control TLS certificate verification. Can be a boolean or a path to a CA bundle file.</p> <pre><code># Disable TLS verification\ntls-verify = false\n\n# Use a custom CA bundle\ntls-verify = \"/path/to/ca-bundle.pem\"\n</code></pre>"},{"location":"reference/configuration/#rate-limit","title":"<code>rate-limit</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>Specify a rate limit for test requests in '/' format. Supports 's' (seconds), 'm' (minutes), and 'h' (hours) as duration units. <pre><code># 100 requests per minute\nrate-limit = \"100/m\"\n\n# 5 requests per second\nrate-limit = \"5/s\"\n\n# 1000 requests per hour\nrate-limit = \"1000/h\"\n</code></pre>"},{"location":"reference/configuration/#request-timeout","title":"<code>request-timeout</code>","text":"<p>Type: <code>Float</code> Default: <code>null</code> </p> <p>Set a timeout limit in seconds for each network request during tests. Must be a positive number.</p> <pre><code># 5-second timeout\nrequest-timeout = 5.0\n\n# 500ms timeout\nrequest-timeout = 0.5\n</code></pre>"},{"location":"reference/configuration/#request-cert","title":"<code>request-cert</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>File path to an unencrypted client certificate for authentication. The certificate can be bundled with a private key (e.g., PEM) or used with a separate private key specified by <code>request-cert-key</code>.</p> <pre><code># Client certificate with bundled private key\nrequest-cert = \"/path/to/client-cert.pem\"\n</code></pre>"},{"location":"reference/configuration/#request-cert-key","title":"<code>request-cert-key</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>File path to the private key for the client certificate when not bundled together.</p> <pre><code># Set certificate and separate private key\nrequest-cert = \"/path/to/client-cert.crt\"\nrequest-cert-key = \"/path/to/private-key.key\"\n</code></pre>"},{"location":"reference/configuration/#data-generation","title":"Data Generation","text":"<p>The following settings control how Schemathesis generates test data for your API testing.</p>"},{"location":"reference/configuration/#generationmode","title":"<code>generation.mode</code>","text":"<p>Type: <code>String</code> Default: <code>\"all\"</code> </p> <p>Test data generation mode. Controls whether Schemathesis generates valid data, invalid data, or both.</p> <p>Possible values: - <code>\"positive\"</code>: Generate only valid data according to the schema - <code>\"negative\"</code>: Generate only invalid data to test error handling - <code>\"all\"</code>: Generate both valid and invalid data</p> <pre><code>[generation]\nmode = \"positive\"\n</code></pre>"},{"location":"reference/configuration/#generationmax-examples","title":"<code>generation.max-examples</code>","text":"<p>Type: <code>Integer</code> Default: <code>100</code> </p> <p>Maximum number of test cases generated per API operation. Must be greater than or equal to 1.</p> <p>This setting has different effects depending on the test phase:</p> <ul> <li>In fuzzing phase: Controls the maximum number of examples generated per API operation</li> <li>In stateful phase: Determines the maximum number of distinct API call sequences</li> <li>In examples and coverage phases: Has no effect, as these use predetermined test cases</li> </ul> <pre><code>[generation]\nmax-examples = 100\n</code></pre>"},{"location":"reference/configuration/#generationseed","title":"<code>generation.seed</code>","text":"<p>Type: <code>Integer</code> Default: <code>null</code> </p> <p>Random seed for reproducible test runs. Setting the same seed value will result in the same sequence of generated test cases.</p> <pre><code>[generation]\nseed = 42\n</code></pre>"},{"location":"reference/configuration/#generationno-shrink","title":"<code>generation.no-shrink</code>","text":"<p>Type: <code>Boolean</code> Default: <code>false</code> </p> <p>Disable test case shrinking. When enabled, Schemathesis won't attempt to simplify failing test cases. This improves performance but makes test failures harder to debug.</p> <pre><code>[generation]\nno-shrink = true\n</code></pre>"},{"location":"reference/configuration/#generationdeterministic","title":"<code>generation.deterministic</code>","text":"<p>Type: <code>Boolean</code> Default: <code>false</code> </p> <p>Enables deterministic mode, which eliminates random variation between tests. Useful for consistency in test outcomes.</p> <pre><code>[generation]\ndeterministic = true\n</code></pre>"},{"location":"reference/configuration/#generationallow-x00","title":"<code>generation.allow-x00</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Controls whether to allow the generation of 'NULL' bytes (0x00) within strings. Some systems may not handle these bytes correctly.</p> <pre><code>[generation]\nallow-x00 = false\n</code></pre>"},{"location":"reference/configuration/#generationcodec","title":"<code>generation.codec</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>The codec used for generating strings. Defines the character encoding for string generation.</p> <pre><code>[generation]\ncodec = \"ascii\"\n</code></pre>"},{"location":"reference/configuration/#generationmaximize","title":"<code>generation.maximize</code>","text":"<p>Type: <code>String</code> Default: <code>null</code> </p> <p>Guide input generation to values more likely to expose bugs via targeted property-based testing.</p> <p>Possible values: - <code>\"response_time\"</code>: Focus on generating inputs that maximize response time</p> <pre><code>[generation]\nmaximize = \"response_time\"\n</code></pre>"},{"location":"reference/configuration/#generationwith-security-parameters","title":"<code>generation.with-security-parameters</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Controls whether to generate security parameters during testing. When enabled, Schemathesis will include appropriate security-related parameters in test data based on the API's security schemes defined in the schema.</p> <pre><code>[generation]\nwith-security-parameters = false\n</code></pre>"},{"location":"reference/configuration/#generationgraphql-allow-null","title":"<code>generation.graphql-allow-null</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code> </p> <p>Controls whether to use <code>null</code> values for optional arguments in GraphQL queries. Applicable only for GraphQL API testing.</p> <pre><code>[generation]\ngraphql-allow-null = false\n</code></pre>"},{"location":"reference/configuration/#generationdatabase","title":"<code>generation.database</code>","text":"<p>Type: <code>String</code> Default: <code>.hypothesis/examples</code> </p> <p>Storage for examples discovered by Schemathesis. Options: - <code>\"none\"</code>: Disable storage - <code>\":memory:\"</code>: Use temporary in-memory storage - File path: For persistent storage in a custom location</p> <p>By default, Schemathesis creates a directory-based example database in your current working directory under <code>.hypothesis/examples</code>. If this location is unusable, Schemathesis will emit a warning and use an alternative.</p> <pre><code>[generation]\ndatabase = \":memory:\"\n\n# Or for persistent storage\ndatabase = \"./schemathesis_examples.db\"\n</code></pre>"},{"location":"reference/configuration/#generationunique-inputs","title":"<code>generation.unique-inputs</code>","text":"<p>Type: <code>Boolean</code> Default: <code>false</code> </p> <p>Force the generation of unique test cases. When enabled, Schemathesis will ensure that no duplicate test inputs are used within a single test phase.</p> <pre><code>[generation]\nunique-inputs = true\n</code></pre>"},{"location":"reference/configuration/#generationfill-missing-examples","title":"<code>generation.fill-missing-examples</code>","text":"<p>Type: <code>Boolean</code> Default: <code>false</code> </p> <p>Enable generation of random examples for API operations that do not have explicit examples in the OpenAPI schema.</p> <pre><code>[generation]\nfill-missing-examples = true\n</code></pre>"},{"location":"reference/python/","title":"Python API Reference","text":""},{"location":"reference/reporting/","title":"Reporting Test Results","text":""},{"location":"using/cli/","title":"Schemathesis CLI","text":"<p>This guide demonstrates practical usage examples of the Schemathesis command-line interface, progressing from basic commands to advanced testing scenarios.</p>"},{"location":"using/cli/#first-test-run","title":"First Test Run","text":"<p>Run default tests against an API schema:</p> <pre><code>$ st run https://example.schemathesis.io/openapi.json\n</code></pre> <p>This command:</p> <ul> <li>Loads the API schema from the specified URL.</li> <li>Generates diverse test cases across multiple test phases.</li> <li>Executes the test cases and runs a suite of checks against the API responses.</li> <li>Automatically minimizes any failing test case to help pinpoint the underlying issue.</li> </ul> <p>Example output:</p> <pre><code>Schemathesis dev\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\n \u2705  Loaded specification from https://schemathesis.io/openapi.json (in 0.32s)\n\n     Base URL:         http://127.0.0.1/api\n     Specification:    Open API 3.0.2\n     Operations:       1 selected / 1 total\n\n \u2705  API capabilities:\n\n     Supports NULL byte in headers:    \u2718\n\n \u23ed   Examples (in 0.00s)\n\n     \u23ed  1 skipped\n\n \u274c  Coverage (in 0.00s)\n\n     \u274c 1 failed\n\n \u274c  Fuzzing (in 0.00s)\n\n     \u274c 1 failed\n\n=================================== FAILURES ===================================\n_________________________________ GET /success _________________________________\n1. Test Case ID: &lt;PLACEHOLDER&gt;\n\n- Response violates schema\n\n    {} is not of type 'integer'\n\n    Schema:\n\n        {\n            \"type\": \"integer\"\n        }\n\n    Value:\n\n        {}\n\n- Missing Content-Type header\n\n    The following media types are documented in the schema:\n    - `application/json`\n\n[200] OK:\n\n    `{}`\n\nReproduce with:\n\n    curl -X GET http://127.0.0.1/api/success\n\n=================================== SUMMARY ====================================\n\nAPI Operations:\n  Selected: 1/1\n  Tested: 1\n\nTest Phases:\n  \u2705 API probing\n  \u23ed  Examples\n  \u274c Coverage\n  \u274c Fuzzing\n  \u23ed  Stateful (not applicable)\n\nFailures:\n  \u274c Response violates schema: 1\n  \u274c Missing Content-Type header: 1\n\nTest cases:\n  N generated, N found N unique failures\n\nSeed: 42\n\n============================= 2 failures in 1.00s ==============================\n</code></pre> <p>The output reveals that the endpoint failed two checks: the response body did not match the expected schema, and the required <code>Content-Type</code> header was missing. A handy curl command is provided to reproduce the failure for debugging.</p> <p>Troubleshooting</p> <p>For common issues with schema loading, authentication, or network connections, see the Troubleshooting Guide.</p>"},{"location":"using/cli/#testing-with-a-local-schema-file","title":"Testing with a Local Schema File","text":"<p>When testing with a local schema file, use the <code>--url</code> flag to specify the appropriate test server: <pre><code>$ st run ./openapi.json --url http://localhost:8000\n</code></pre></p>"},{"location":"using/cli/#changing-the-test-scope","title":"Changing the Test Scope","text":"<p>By default, Schemathesis tests all operations in your API schema. However, you can narrow down the testing scope to focus on specific parts of your API, which is particularly useful for:</p> <ul> <li>Testing only recently changed endpoints</li> <li>Focusing on critical paths during quick validation</li> <li>Excluding endpoints that are known to be problematic</li> <li>Running separate test suites for different API areas</li> </ul>"},{"location":"using/cli/#basic-filtering","title":"Basic Filtering","text":"<p>Filter operations by HTTP method:</p> <pre><code>$ st run --include-method GET ...\n</code></pre> <p>Filter by path pattern using regular expressions:</p> <pre><code>$ st run --include-path-regex '^/users' ...\n</code></pre>"},{"location":"using/cli/#filtering-options-reference","title":"Filtering Options Reference","text":"<p>Schemathesis offers a comprehensive set of filtering options using this pattern:</p> <pre><code>--{include,exclude}-{path,method,name,tag,operation-id} TEXT\n--{include,exclude}-{path,method,name,tag,operation-id}-regex TEXT\n</code></pre> <p>Examples:</p> <pre><code># Test only POST endpoints\n$ st run --include-method POST ...\n\n# Exclude all user-related endpoints\n$ st run --exclude-path-regex '^/users' ...\n\n# Test only endpoints with 'admin' tag\n$ st run --include-tag admin ...\n\n# Focus on specific operations by ID\n$ st run --include-operation-id createUser --include-operation-id getUser ...\n</code></pre> <p>Note</p> <p>The <code>name</code> property in Schemathesis refers to the full operation name. For OpenAPI, it is formatted as <code>METHOD PATH</code> (e.g., <code>GET /users</code>). For GraphQL, it follows the pattern <code>OperationType.field</code> (e.g., <code>Query.getBookings</code>).</p>"},{"location":"using/cli/#advanced-filtering","title":"Advanced Filtering","text":"<p>You can combine multiple filters to create precise test scopes:</p> <pre><code>$ st run --include-method POST --include-method PUT --exclude-tag admin ...\n</code></pre> <p>This example tests only POST and PUT operations that don't have the \"admin\" tag.</p>"},{"location":"using/cli/#filtering-by-schema-properties","title":"Filtering by Schema Properties","text":"<p>For more advanced scenarios, filter operations based on their schema definition:</p> <pre><code>$ st run --include-by=\"/x-priority == 'high'\" ...\n</code></pre> <p>This selects operations where the <code>x-priority</code> custom property equals \"high\". The expression follows this format:</p> <pre><code>\"&lt;pointer&gt; &lt;operator&gt; &lt;value&gt;\"\n</code></pre> <p>Where:</p> <ul> <li><code>&lt;pointer&gt;</code> is a JSON Pointer to a value in the operation definition</li> <li><code>&lt;operator&gt;</code> can be <code>==</code> or <code>!=</code></li> <li><code>&lt;value&gt;</code> is the value to compare against (treated as a string if not valid JSON)</li> </ul>"},{"location":"using/cli/#excluding-deprecated-operations","title":"Excluding Deprecated Operations","text":"<p>To skip all operations marked as deprecated in the schema:</p> <pre><code>$ st run --exclude-deprecated ...\n</code></pre> <p>GraphQL Support</p> <p>For GraphQL schemas, Schemathesis only supports filtration by the <code>name</code> property.</p>"},{"location":"using/cli/#authentication-and-headers","title":"Authentication and Headers","text":"<p>Schemathesis supports various authentication methods: token-based headers, HTTP Basic Auth, and advanced multi-step flows. Authentication settings apply to all API requests made during testing.</p>"},{"location":"using/cli/#token-based-authentication","title":"Token-based Authentication","text":""},{"location":"using/cli/#api-keys","title":"API Keys","text":"<p>To provide an API key via header:</p> <pre><code>$ st run openapi.yaml --header \"X-API-Key: your-api-key-here\"\n</code></pre> <p>Store tokens in environment variables to avoid exposing them in command history:</p> <pre><code>$ st run openapi.yaml --header \"X-API-Key: ${API_KEY}\"\n</code></pre>"},{"location":"using/cli/#bearer-tokens","title":"Bearer Tokens","text":"<p>For Bearer token authentication:</p> <pre><code>$ st run openapi.yaml --header \"Authorization: Bearer your-token-here\"\n</code></pre> <p>Specify multiple headers by repeating the <code>--header</code> option:</p> <pre><code>$ st run openapi.yaml \\\n  --header \"Authorization: Bearer ${TOKEN}\" \\\n  --header \"X-Tenant-ID: ${TENANT_ID}\"\n</code></pre>"},{"location":"using/cli/#basic-authentication","title":"Basic Authentication","text":"<p>For HTTP Basic Auth, use <code>--auth</code>:</p> <pre><code>$ st run openapi.yaml --auth username:password\n</code></pre> <p>Schemathesis automatically encodes credentials in the <code>Authorization</code> header.</p>"},{"location":"using/cli/#using-configuration-files","title":"Using Configuration Files","text":"<p>Configuration files allow you to set default authentication or override it for specific API operations. This flexible approach supports all authentication types, including OpenAPI security schemes, which are automatically applied when required by the API.</p> <p>By default, Schemathesis automatically loads a <code>schemathesis.toml</code> file from the current directory or project root. To use a custom configuration file, specify its path with the <code>--config</code> option:</p> <pre><code>$ st run openapi.yaml --config config.toml\n</code></pre> <p>For more details, see the Authentication Configuration Reference section. For example:</p> <pre><code>[auth]\nbearer = \"${TOKEN}\"\n\n[auth.openapi]\nApiKeyAuth = { value = \"${API_KEY}\" }\n</code></pre>"},{"location":"using/cli/#advanced-authentication","title":"Advanced Authentication","text":"<p>For complex or multi-step authentication flows that require custom logic, please refer to the Extensions Guide.</p> <p>Third-Party Authentication</p> <p>Python extensions allow you to use third-party libraries for specialized protocols. For example, you can use <code>requests_ntlm</code> for NTLM authentication</p>"},{"location":"using/cli/#test-phases","title":"Test Phases","text":"<p>Schemathesis divides testing into distinct phases\u2014each designed to detect specific API issues.</p>"},{"location":"using/cli/#available-phases","title":"Available Phases","text":"<p>Schemathesis supports four test phases:</p> <ul> <li>Examples: Uses schema-defined examples for quick verification.  </li> <li>Coverage: Systematically tests boundary values, constraints, and edge cases.  </li> <li>Fuzzing: Uses randomized data to uncover unexpected edge cases.  </li> <li>Stateful: Tests sequences of API calls to assess stateful behavior.</li> </ul> <p>By default, all phases are enabled.</p> <p>Note: The stateful phase can significantly increase test duration.</p>"},{"location":"using/cli/#selecting-phases","title":"Selecting Phases","text":"<p>Use the <code>--phases</code> option with a comma-separated list to specify which phases to run:</p> <pre><code>$ st run openapi.yaml --phases examples,fuzzing\n</code></pre> <p>To run a single phase:</p> <pre><code>$ st run openapi.yaml --phases coverage\n</code></pre> <p>For more information about test phases, including how they work and when to use them, see the Test Phases section.</p>"},{"location":"using/cli/#data-generation","title":"Data Generation","text":"<p>Schemathesis generates test data for API operations based on your schema. These options let you control how test data is created.</p>"},{"location":"using/cli/#test-data-modes","title":"Test Data Modes","text":"<p>The <code>--mode</code> option determines whether Schemathesis generates valid data, invalid data, or both:</p> <pre><code>$ st run openapi.yaml --mode positive\n</code></pre> <p>Available modes:</p> <ul> <li><code>positive</code>: Generate only valid data that should be accepted by the API</li> <li><code>negative</code>: Generate data that violates schema constraints to test error handling (slower generation)</li> <li><code>all</code>: Generate both valid and invalid data (default)</li> </ul> <p>In negative mode, if your schema has a constraint like <code>minimum: 1</code>, Schemathesis might generate values like <code>0</code> or <code>-5</code> to test how your API handles invalid inputs.</p> <p>Use <code>--mode positive</code> during initial API development to focus on core functionality before testing error handling.</p>"},{"location":"using/cli/#number-of-examples","title":"Number of Examples","text":"<p>The <code>--max-examples</code> option controls the maximum number of test cases:</p> <pre><code>$ st run openapi.yaml --max-examples 50\n</code></pre> <p>By default, Schemathesis generates up to 100 test cases per operation.</p> <ul> <li>In unit testing phases (examples, coverage, fuzzing): Limits the number of test cases per operation</li> <li>In stateful testing: Controls the number of API calls in a single sequence</li> <li>Testing may finish earlier if Schemathesis finds a failure or exhausts all possible inputs</li> </ul> <p>For a parameter with constraints like <code>minimum: 1, maximum: 10</code>, Schemathesis might generate fewer than your requested examples if it exhausts all meaningful test cases.</p> <ul> <li>Lower values (10-50) provide faster feedback during development</li> <li>Higher values (100+) find more edge cases but take longer to execute</li> <li>Use <code>--continue-on-failure</code> to test all examples even after finding failures</li> </ul>"},{"location":"using/cli/#reproducibility","title":"Reproducibility","text":"<p>Use the <code>--seed</code> option to make test data generation reproducible in the same environment:</p> <pre><code>$ st run openapi.yaml --seed 42\n</code></pre> <p>With a fixed seed, Schemathesis generates the same sequence of test data within the same environment, which helps:</p> <ul> <li>Reproduce reported issues: \"Test fails with seed 12345\"</li> <li>Create predictable test runs in CI/CD environments</li> </ul> <p>Using the same seed only guarantees identical test data when other factors remain constant - including schema definition, API behavior, Schemathesis version, and Python version.</p> <p>For additional data generation options, see the Data Generation Reference.</p>"},{"location":"using/cli/#checks","title":"Checks","text":"<p>Checks are validations Schemathesis performs on API responses to verify correct behavior according to specifications.</p> <p>All checks are enabled by default. Customize them to focus on schema compliance, server crashes or stateful issues as needed.</p>"},{"location":"using/cli/#selecting-checks","title":"Selecting Checks","text":"<p>Customize the test run by specifying the checks to include using the <code>--checks</code> option:</p> <pre><code>$ st run openapi.yaml --checks not_a_server_error,response_schema_conformance\n</code></pre> <p>Disable specific checks while retaining others by using the <code>--exclude-checks</code> option:</p> <pre><code>$ st run openapi.yaml --exclude-checks negative_data_rejection\n</code></pre> <p>Use <code>--checks</code> to run only the listed checks, or <code>--exclude-checks</code> to run all checks except the ones you specify.</p>"},{"location":"using/cli/#response-time-validation","title":"Response Time Validation","text":"<p>Use the <code>--max-response-time</code> option to ensure API responses are received within a specified time frame:</p> <p><pre><code>$ st run openapi.yaml --max-response-time 0.5\n</code></pre> In this example, tests will fail for any API response that takes longer than 500 milliseconds, helping you identify slow endpoints.</p>"},{"location":"using/cli/#common-check-combinations","title":"Common Check Combinations","text":"<p>Different testing goals require different check combinations. Here's a common scenario:</p>"},{"location":"using/cli/#schema-compliance-testing","title":"Schema Compliance Testing","text":"<p>For schema compliance testing, run only the checks that validate response status codes, content types, and schema structures:</p> <pre><code>$ st run openapi.yaml --checks \\\n    status_code_conformance,content_type_conformance,response_schema_conformance\n</code></pre> <p>This combination ensures responses use the expected status codes, content types, and schema structures without testing additional behavior like authentication bypass.</p> <p>For more information about checks, including what they validate and when to use them, see the Checks Reference.</p>"},{"location":"using/cli/#reporting-test-results","title":"Reporting Test Results","text":"<p>Schemathesis can generate structured reports of test results for integration with CI systems, sharing findings with your team, and analyzing API behavior.</p>"},{"location":"using/cli/#report-types-and-use-cases","title":"Report Types and Use Cases","text":"<p>Schemathesis supports three report formats, each serving different purposes:</p> <ul> <li> <p>JUnit XML: Integration with CI systems like Jenkins or GitLab CI. Provides structured test results that can be visualized in test reporting dashboards.</p> </li> <li> <p>VCR Cassettes: Debugging API issues by preserving complete request and response details. Includes metadata like test case IDs and check results in YAML format.</p> </li> <li> <p>HAR Files: Analyzing HTTP traffic with browser developer tools or third-party applications. Provides a standard format compatible with HTTP analyzers.</p> </li> </ul>"},{"location":"using/cli/#generating-and-storing-reports","title":"Generating and Storing Reports","text":"<p>By default, Schemathesis doesn't generate any reports. Use the <code>--report</code> option with a comma-separated list of formats:</p> <pre><code>$ st run openapi.yaml --report junit,vcr\n</code></pre> <p>Reports are stored in the <code>schemathesis-report</code> directory by default. You can change this with <code>--report-dir</code>:</p> <pre><code>$ st run openapi.yaml --report junit --report-dir ./test-results\n</code></pre> <p>Files in the report directory are overwritten on each run. Use unique directories or filenames for tests you want to preserve.</p> <p>For specific report types, you can customize the output path:</p> <pre><code>$ st run openapi.yaml \\\n  --report junit \\\n  --report-junit-path ./jenkins/schemathesis-results.xml\n</code></pre> <p>Similar options exist for other formats:</p> <pre><code>$ st run openapi.yaml \\\n  --report vcr \\\n  --report-vcr-path ./debug/api-responses.yaml\n\n$ st run openapi.yaml \\\n  --report har \\\n  --report-har-path ./analysis/http-archive.har\n</code></pre> <p>For detailed information about report structures and advanced usage, see the Reporting Reference.</p>"},{"location":"using/cli/#docker-usage","title":"Docker Usage","text":"<p>Schemathesis is available as a Docker image, allowing you to run API tests without installing the CLI directly on your system.</p>"},{"location":"using/cli/#basic-docker-command","title":"Basic Docker Command","text":"<p>The simplest way to run Schemathesis via Docker is to use a remote schema URL:</p> <pre><code>$ docker run schemathesis/schemathesis:stable \\\n    run http://api.example.com/openapi.json\n</code></pre> <p>Enabling Color Output</p> <p>By default, Docker containers don't enable color output. Use the <code>--force-color</code> option if your terminal supports colors.</p>"},{"location":"using/cli/#network-configuration-by-platform","title":"Network Configuration by Platform","text":"<p>Network configuration varies by platform when testing local APIs:</p>"},{"location":"using/cli/#linux","title":"\ud83d\udc27 Linux","text":"<p>On Linux, use the <code>--network=host</code> parameter to access services running on your local machine:</p> <pre><code>$ docker run --network=host schemathesis/schemathesis:stable \\\n    run http://localhost:8000/openapi.json\n</code></pre>"},{"location":"using/cli/#macos","title":"\ud83c\udf4e macOS","text":"<p>On macOS, Docker cannot directly access the host's <code>localhost</code>. Use the special DNS name <code>host.docker.internal</code> instead:</p> <pre><code>$ docker run schemathesis/schemathesis:stable \\\n    run http://host.docker.internal:8000/openapi.json\n</code></pre>"},{"location":"using/cli/#windows","title":"\ud83e\ude9f Windows","text":"<p>On Windows, similar to macOS, use <code>host.docker.internal</code> to access services on your host machine:</p> <pre><code>$ docker run schemathesis/schemathesis:stable \\\n   run http://host.docker.internal:8000/openapi.json\n</code></pre>"},{"location":"using/cli/#volume-mounting-for-local-files","title":"Volume Mounting for Local Files","text":"<p>If your API schema is stored locally, you can mount it into the container:</p> <p>For shells like bash, zsh, or sh:</p> <pre><code>$ docker run -v $(pwd):/app schemathesis/schemathesis:stable \\\n    run /app/openapi.json\n</code></pre> <p>In these examples, the current working directory is mounted to <code>/app</code> inside the container, making local files accessible to Schemathesis.</p> <p>When using volume mounting, you can also output reports to the local filesystem:</p> <pre><code>$ docker run -v $(pwd):/app schemathesis/schemathesis:stable \\\n    run /app/openapi.json \\\n    --report junit --report-dir /app/test-results\n</code></pre> <p>This command will generate the JUnit report in the <code>test-results</code> directory on your local machine.</p>"},{"location":"using/cli/#next-steps","title":"Next Steps","text":"<p>Should you wish to go beyond the discussed CLI usage you can check the following:</p> <ul> <li> <p>See the CLI Reference for a complete list of all available command-line options</p> </li> <li> <p>Check Extension Mechanisms to implement custom checks, hooks, or data generators when standard functionality doesn't meet your requirements</p> </li> </ul>"},{"location":"using/configuration/","title":"Configuration","text":"<p>Schemathesis can be configured through a <code>schemathesis.toml</code> file.</p>"},{"location":"using/configuration/#configuration-file-location","title":"Configuration File Location","text":"<p>Schemathesis will look for configuration in the following locations, in order:</p> <ol> <li>Path specified via <code>--config</code> CLI option.</li> <li><code>schemathesis.toml</code> in the current directory.</li> <li><code>schemathesis.toml</code> in parent directories (up to the project root).</li> </ol> <p>Configuration Preference</p> <p>Schemathesis uses only one configuration file and does not merge settings from multiple files. If no <code>schemathesis.toml</code> file is found, Schemathesis will use its built-in defaults.</p>"},{"location":"using/configuration/#why-use-a-configuration-file","title":"Why Use a Configuration File?","text":"<p>While Schemathesis works well without explicit configuration, using a file offers several benefits:</p> <ul> <li>Operation-Specific Settings: Configure different behaviors for specific API operations. For example, run more tests or apply different validation rules</li> <li>Validation Customization: Adjust how API responses are validated. For example, trigger certain failures on non-default status codes.</li> <li>Consistent Testing: Share configuration across different environments and test runs.</li> </ul> <p>CLI and Python API Integration</p> <p>While the configuration file sets default behavior, CLI options and the Python API can override any settings.</p> <p>For a complete list of settings, see the Configuration Reference.</p>"},{"location":"using/configuration/#basic-structure","title":"Basic Structure","text":"<p>Schemathesis configuration uses the TOML format with a hierarchical structure. Global settings serve as defaults and can be overridden by more specific ones such as operation-specific or project-specific configurations.</p> <pre><code># Global settings\nbase-url = \"https://api.example.com\"\ngeneration.max-examples = 100\n\n# Operation-specific settings\n[operation.\"GET /users\"]\ngeneration.max-examples = 200\nrequest-timeout = 5.0\n</code></pre>"},{"location":"using/configuration/#environment-variable-substitution","title":"Environment Variable Substitution","text":"<p>Schemathesis supports using environment variables in configuration files with the <code>${VAR_NAME}</code> syntax:</p> <pre><code># Use environment variables for sensitive or environment-specific values\nbase-url = \"https://${API_HOST}/v1\"\nheaders = { \"Authorization\" = \"Bearer ${API_TOKEN}\" }\n\n[operation.\"POST /payments\"]\nheaders = { \"X-API-Key\" = \"${PAYMENTS_API_KEY}\" }\n</code></pre> <p>This allows you to maintain a single configuration file that works across different environments (development, staging) by changing environment variables rather than the configuration itself.</p> <p>Multi-Project Support</p> <p>Schemathesis also supports multi-project configurations, where you can define separate settings for different APIs within the same configuration file. See Multi-Project Configuration for details.</p> <p>Most users won't need a configuration file at all. Configuration becomes valuable primarily for complex testing scenarios or multi-API environments.</p>"},{"location":"using/configuration/#authentication","title":"Authentication","text":"<p>Schemathesis supports multiple authentication methods for API testing.</p> <p>For simple authentication, use the top-level <code>[auth]</code> section:</p> <pre><code>[auth]\n# Basic authentication\nbasic = { username = \"${USERNAME}\", password = \"${PASSWORD}\" }\n\n# Bearer token authentication\nbearer = \"${TOKEN}\"\n</code></pre> <p>The basic setting corresponds to the <code>--auth</code> CLI option, while bearer tokens can also be specified via CLI headers.</p>"},{"location":"using/configuration/#openapi-security-schemes","title":"OpenAPI Security Schemes","text":"<p>For OpenAPI specifications with defined security schemes, configure them by name:</p> <pre><code>[auth.openapi]\n# Basic HTTP authentication\nBasicAuth = { username = \"${USERNAME}\", password = \"${PASSWORD}\" }\n\n# Bearer token authentication\nBearerAuth = { token = \"${TOKEN}\" }\n\n# API Key authentication\nApiKeyAuth = { value = \"${API_KEY}\" }\n\n# OAuth2 authentication\nOAuth2 = { \n  client_id = \"${CLIENT_ID}\", \n  client_secret = \"${CLIENT_SECRET}\",\n  scopes = [\"read\", \"write\"]\n}\n</code></pre> <p>These settings map directly to the <code>securitySchemes</code> in your OpenAPI specification.</p>"},{"location":"using/configuration/#authentication-resolution","title":"Authentication Resolution","text":"<p>When multiple methods are specified, Schemathesis resolves authentication in the following order:</p> <ul> <li>CLI options (<code>--auth</code> or <code>--header</code>)</li> <li>Operation-specific headers</li> <li>Specification-specific authentication (<code>[auth.openapi]</code>)</li> <li>Generic authentication (top-level <code>[auth]</code>)</li> </ul> <p>This flexible resolution lets you override settings at different levels while keeping sensitive data in environment variables.</p>"},{"location":"using/configuration/#test-phases","title":"Test Phases","text":"<p>Schemathesis runs tests in distinct phases, each with different approaches to generating and executing test cases.</p>"},{"location":"using/configuration/#available-phases","title":"Available Phases","text":"<p>Schemathesis includes the following test phases:</p> <ul> <li>examples: Tests using examples explicitly defined in your API schema</li> <li>coverage: Tests using deterministic edge cases and boundary values</li> <li>fuzzing: Tests using randomly generated values</li> <li>stateful: Tests API operation sequences to find state-dependent issues</li> </ul> <p>All phases are enabled by default.</p>"},{"location":"using/configuration/#phase-configuration","title":"Phase Configuration","text":"<p>Customize test phases using the <code>[phases]</code> section in your configuration file. For example:</p> <pre><code>[phases]\n# Disable a specific phase\ncoverage.enabled = false\n\n# Phase-specific settings\n# Maximum number of distinct API call sequences\nstateful.generation.max-examples = 30\n# Maximum examples per operation in fuzzing phase\nfuzzing.generation.max-examples = 200\n</code></pre>"},{"location":"using/configuration/#phase-specific-behavior","title":"Phase-Specific Behavior","text":"<p>Certain settings are interpreted differently across test phases. For instance, the <code>generation.max-examples</code> setting works as follows:</p> <ul> <li>fuzzing: Controls the maximum number of examples generated per API operation.</li> <li>stateful: Determines the maximum number of distinct API call sequences.</li> </ul> <p>Phases that use predetermined test cases (such as the examples and coverage phases) are unaffected by the <code>generation.max-examples</code> setting.</p> <p>Consider this example, which sets a global default while overriding it for the stateful phase:</p> <pre><code># Global setting\ngeneration.max-examples = 200\n\n[phases]\n# Override for stateful phase\nstateful.generation.max-examples = 30\n</code></pre>"},{"location":"using/configuration/#checks","title":"Checks","text":"<p>Schemathesis validates API responses with a series of checks that verify various aspects of your API's behavior\u2014from server availability to schema conformance.</p>"},{"location":"using/configuration/#available-checks","title":"Available Checks","text":"<p>Schemathesis includes the following checks (all enabled by default):</p> <ul> <li>not_a_server_error: Ensures the API doesn't return 5xx responses.</li> <li>status_code_conformance: Confirms status codes match the schema.</li> <li>content_type_conformance: Validates response content types against the schema.</li> <li>response_schema_conformance: Checks that response bodies conform to their defined schemas.</li> <li>positive_data_acceptance: Verifies that valid data is accepted.</li> <li>negative_data_rejection: Ensures that invalid data is rejected.</li> <li>use_after_free: Checks that resources are inaccessible after deletion.</li> <li>ensure_resource_availability: Verifies that resources are available post-creation.</li> <li>ignored_auth: Ensures authentication is properly enforced.</li> </ul>"},{"location":"using/configuration/#global-check-configuration","title":"Global Check Configuration","text":"<p>Configure checks globally using the <code>[checks]</code> section:</p> <pre><code>[checks]\n# Disable checks globally\ncontent_type_conformance.enabled = false\n\n# Set check parameters\npositive_data_acceptance.expected-statuses = [200, 201, 202]\nnegative_data_rejection.expected-statuses = [400, 422]\n</code></pre>"},{"location":"using/configuration/#operation-specific-check-configuration","title":"Operation-Specific Check Configuration","text":"<p>Override check settings for a specific operation:</p> <pre><code>[operation.\"POST /users\"]\n# Operation-specific check settings\nchecks.positive_data_acceptance.expected-statuses = [201]\nchecks.response_schema_conformance.enabled = false\n</code></pre>"},{"location":"using/configuration/#disabling-all-checks-except-selected-ones","title":"Disabling All Checks Except Selected Ones","text":"<p>To run only specific checks, disable all by default and then enable chosen ones:</p> <pre><code>[checks]\nenabled = false\n\n# Enable only selected checks\nnot_a_server_error.enabled = true\nstatus_code_conformance.enabled = true\n</code></pre> <p>This configuration runs only the server error and status code checks.</p>"},{"location":"using/configuration/#check-resolution","title":"Check Resolution","text":"<p>Schemathesis applies check configurations in the following order:</p> <ul> <li>Operation-specific check configuration</li> <li>Global check configuration</li> <li>Default check behavior</li> </ul> <p>This hierarchy lets you define global defaults while overriding settings for specific endpoints.</p>"},{"location":"using/configuration/#operation-targeting","title":"Operation Targeting","text":"<p>Schemathesis lets you target specific API operations for custom configuration. Note that different specifications use different operation identifiers.</p>"},{"location":"using/configuration/#targeting-by-exact-path","title":"Targeting by Exact Path","text":"<p>Specify an operation using its exact identifier:</p> <pre><code># OpenAPI: HTTP method and path\n[operation.\"GET /users\"]\ngeneration.max-examples = 200\nrequest-timeout = 5.0\n\n# GraphQL: type and field name\n[operation.\"Query.getUser\"]\ngeneration.max-examples = 200\n</code></pre>"},{"location":"using/configuration/#targeting-with-regular-expressions","title":"Targeting with Regular Expressions","text":"<p>Select multiple operations matching a pattern:</p> <pre><code># Match operations with paths containing \"users\"\n[operation.regex.\"GET /users/.*\"]\ngeneration.max-examples = 150\n\n# Match operations that modify users\n[operation.regex.\"(POST|PUT|PATCH) /users.*\"]\nrequest-timeout = 3.0\n</code></pre> <p>Regex patterns</p> <p>Regex patterns work with schema path templates, not resolved URLs.</p>"},{"location":"using/configuration/#targeting-by-tag","title":"Targeting by Tag","text":"<p>Apply settings to all operations with a specific tag:</p> <pre><code>[operation.tag.\"admin\"]\nenabled = false  # Skip all admin-tagged operations\n\n[operation.tag.\"payment\"]\ngeneration.max-examples = 150\nrate-limit = \"20/s\"\n</code></pre>"},{"location":"using/configuration/#targeting-with-expressions","title":"Targeting with Expressions","text":"<p>For more precise control, Schemathesis supports targeting operations using JSONPath-like expressions that query specific fields within operation definitions:</p> <pre><code>[operation.expr.\"tags/0 == 'user'\"]\ngeneration.max-examples = 150\n\n[operation.expr.\"operationId == null\"]\nenabled = false\n\n[operation.expr.\"responses/200/description != 'Success'\"]\nchecks.response_schema_conformance.enabled = false\n</code></pre> <p>Expressions follow the pattern <code>&lt;json-pointer&gt; &lt;operator&gt; &lt;value&gt;</code> where:</p> <ul> <li><code>&lt;json-pointer&gt;</code> is a path to a field in the operation definition</li> <li><code>&lt;operator&gt;</code> is either <code>==</code> (equals) or <code>!=</code> (not equals)</li> <li><code>&lt;value&gt;</code> can be a string, number, boolean, null, array, or object</li> </ul> <p>This is particularly useful for:</p> <ul> <li>Targeting operations based on description content</li> <li>Selecting operations with specific response codes</li> <li>Filtering by operation metadata or extension fields</li> </ul>"},{"location":"using/configuration/#examples","title":"Examples","text":"<pre><code># Target operations that include 'admin' in their summary\n[operation.expr.\"summary == 'Admin operations'\"]\nenabled = false\n\n# Target operations that handle file uploads\n[operation.expr.\"requestBody/content/multipart\\\\/form-data != null\"]\ngeneration.max-examples = 50\n\n# Target operations without tags\n[operation.expr.\"tags == null\"]\nchecks.response_schema_conformance.enabled = false\n</code></pre> <p>Expression-based targeting is particularly useful with complex API specifications where tag-based or path-based selection isn't specific enough.</p>"},{"location":"using/configuration/#operation-resolution","title":"Operation Resolution","text":"<p>When multiple selectors match an endpoint, Schemathesis applies them in this order:</p> <ul> <li>Exact path selectors (highest precedence)</li> <li>Tag selectors</li> <li>Regex selectors (lowest precedence)</li> </ul> <p>Within each category, more specific selectors override general ones.</p>"},{"location":"using/configuration/#phase-specific-settings-for-operations","title":"Phase-Specific Settings for Operations","text":"<p>Configure phase-specific settings within individual operations for fine-grained control over each phase's behavior:</p> <pre><code>[operation.\"GET /users\"]\n# Default settings for this operation\ngeneration.max-examples = 100\nrequest-timeout = 5.0\n\n# Phase-specific overrides for this operation\n[operation.\"GET /users\".phases]\nfuzzing.generation.max-examples = 200  # Increase examples for fuzzing\nstateful.generation.max-examples = 30   # Reduce examples for stateful tests\n</code></pre>"},{"location":"using/configuration/#resolution-order-for-phase-operation-settings","title":"Resolution Order for Phase-Operation Settings","text":"<p>When both operation-level and phase-level settings are defined, Schemathesis applies them in the following order:</p> <ul> <li>Operation-specific phase settings (e.g., <code>[operation.\"GET /users\".phases.fuzzing]</code>)</li> <li>Global phase settings (e.g., <code>[phases.fuzzing]</code>)</li> <li>Operation-level settings (e.g., <code>[operation.\"GET /users\"]</code>)</li> <li>Global settings (top level)</li> </ul> <p>This hierarchy allows you to set defaults at higher levels while overriding specific phases as needed.</p>"},{"location":"using/configuration/#parameter-overrides","title":"Parameter Overrides","text":"<p>Override parameter values at different levels to control test data.</p>"},{"location":"using/configuration/#operation-specific-parameters","title":"Operation-Specific Parameters","text":"<p>Set parameter values for specific operations:</p> <pre><code>[operation.\"GET /users/{user_id}\"]\n# Fixed value\nparameters = { \"user_id\" = 42 }\n\n# Multiple values for random selection\nparameters = { \"user_id\" = [1, 42, 499] }\n\n# Using an environment variable\nparameters = { \"user_id\" = \"${USER_ID}\" }\n\n# Disambiguate parameters with the same name\nparameters = { \"path.user_id\" = 42, \"query.user_id\" = 100 }\n</code></pre>"},{"location":"using/configuration/#global-parameter-overrides","title":"Global Parameter Overrides","text":"<p>Apply parameters across all operations:</p> <pre><code>[parameters]\n\"api_version\" = \"v2\"\n\"limit\" = 50\n\"offset\" = 0\n</code></pre>"},{"location":"using/configuration/#parameter-resolution-order","title":"Parameter Resolution Order","text":"<p>Schemathesis resolves parameter values in this order:</p> <ul> <li>Operation-specific values</li> <li>Global values</li> <li>Generated values from the schema</li> </ul> <p>This cascading mechanism ensures that more specific settings override general ones.</p>"},{"location":"using/configuration/#parameter-type-disambiguation","title":"Parameter Type Disambiguation","text":"<p>When parameters share the same name, prefix them to indicate their location:</p> <pre><code>parameters = {\n  \"path.id\" = 42,            # Path parameter\n  \"query.id\" = 100,          # Query parameter\n  \"header.X-API-Version\" = \"2.0\",  # Header parameter\n  \"cookie.session\" = \"${SESSION_ID}\"  # Cookie parameter\n}\n</code></pre>"},{"location":"using/configuration/#using-parameter-arrays","title":"Using Parameter Arrays","text":"<p>Provide an array of values; Schemathesis will randomly select one per test case:</p> <pre><code>[operation.\"GET /users\"]\nparameters = { \"role\" = [\"admin\", \"user\", \"guest\"] }\n</code></pre> <p>This configuration distributes the specified roles across test cases.</p>"},{"location":"using/configuration/#multi-project-configuration","title":"Multi-Project Configuration","text":"<p>Schemathesis lets you configure multiple API projects in one file\u2014a handy feature for testing related APIs or different API versions.</p>"},{"location":"using/configuration/#defining-projects","title":"Defining Projects","text":"<p>Define projects in the <code>[projects]</code> section by matching the API's title:</p> <pre><code>[projects]\n# Projects are matched by the API schema's info.title\npayments = { title = \"Payment Processing API\" }\nusers = { title = \"User Management Service\" }\n</code></pre> <p>Schemathesis checks the <code>info.title</code> field of the API schema to apply the corresponding project settings.</p>"},{"location":"using/configuration/#project-specific-settings","title":"Project-Specific Settings","text":"<p>Override global defaults with project-specific settings:</p> <pre><code>[projects.payments]\nbase-url = \"https://payments.example.com\"\nworkers = 4\ngeneration.max-examples = 200\nhooks = \"payment_hooks.py\"\n\n[projects.users]\nbase-url = \"https://users.example.com\"\nworkers = 2\n</code></pre>"},{"location":"using/configuration/#project-specific-operations","title":"Project-Specific Operations","text":"<p>Customize operations within a project:</p> <pre><code>[projects.payments.operation.\"POST /payments\"]\ngeneration.max-examples = 80\nheaders = { \"X-Idempotency-Key\" = \"${IDEMPOTENCY_KEY}\" }\n\n[projects.payments.operation.tag.\"critical\"]\nrequest-timeout = 10.0\n</code></pre>"},{"location":"using/configuration/#configuration-resolution","title":"Configuration Resolution","text":"<p>When using projects, settings are applied in this order:</p> <ul> <li>Operation-specific settings within the project</li> <li>Project-level settings</li> <li>Default operation settings (unprefixed)</li> <li>Global settings</li> </ul>"},{"location":"using/configuration/#example-complete-multi-project-configuration","title":"Example: Complete Multi-Project Configuration","text":"<pre><code># Global defaults\ngeneration.max-examples = 50\nworkers = \"auto\"\n\n[projects]\n# Define projects by API title\npayments = { title = \"Payment Processing API\" }\nusers = { title = \"User Management API\" }\n\n# Payments project settings\n[projects.payments]\nbase-url = \"https://payments.example.com\"\ngeneration.max-examples = 100\n\n# Operations for payments\n[projects.payments.operation.\"POST /payments\"]\ngeneration.max-examples = 200\nparameters = { \"amount\" = [10, 100, 1000] }\nchecks.positive_data_acceptance.expected-statuses = [200, 201]\n\n# Users project settings\n[projects.users]\nbase-url = \"https://users.example.com\"\n</code></pre> <p>With this setup, each project uses its own settings while sharing a common configuration structure.</p>"},{"location":"using/configuration/#configuration-overrides","title":"Configuration Overrides","text":"<p>While the configuration file provides default settings, you can override them via CLI options.</p>"},{"location":"using/configuration/#cli-overrides","title":"CLI Overrides","text":"<p>Command-line arguments take precedence over configuration file settings:</p> <pre><code># Override the max-examples setting\nschemathesis run --max-examples=300 http://api.example.com/openapi.json\n\n# Override phases\nschemathesis run --phases=examples,fuzzing http://api.example.com/openapi.json\n\n# Override check settings\nschemathesis run --checks=not_a_server_error http://api.example.com/openapi.json\n</code></pre> <p>Most configuration option can be overridden via the corresponding CLI flag.</p>"},{"location":"using/python-integration/","title":"Using Schemathesis in Python","text":""}]}